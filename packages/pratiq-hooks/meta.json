{
  "useAsync.tsx": {
    "title": "useAsync",
    "description": "??",
    "doc": "",
    "content": "// import { useState, useEffect, useMemo, useCallback, useRef } from 'react'\n//@ts-ignore\nimport { isBrowser } from '@pratiq/utils'\nimport debug from 'debug'\nconst log = debug('@pq:useAsync')\n// export type UseAsyncConfig = {\n//     \n//     initialData?: any;\n//     \n//     autoLoad?: boolean;\n//     \n//     deps?: any[];\n// }\n// type UseAsyncReturn = {\n//     loading: boolean;\n//     done: boolean;\n//     error: any;\n//     data: any;\n//     reload: Function;\n//     reset: Function;\n// }\n// type UseAsyncType = (callback: Function, config?: UseAsyncConfig) => UseAsyncReturn;\nimport { useCallback, useEffect, useRef, useState } from 'react';\nexport type UseAsyncConfig = {\n    initialData?: any;\n    autoLoad?: boolean;\n    deps?: any[];\n};\nexport type UseAsyncReturn = {\n    loading: boolean;\n    done: boolean;\n    error: any;\n    data: any; \n    reload: Function;\n    reset: Function;\n};\ntype UseAsyncType = (callback: (...args: any[]) => Promise<any>, config?: UseAsyncConfig) => UseAsyncReturn;\nconst useAsync: UseAsyncType = (callback, config = {}) => {\n    const cache = useRef<Map<string, any>>(new Map());\n    const abortControllerRef = useRef<AbortController | null>(null);\n    const [loading, setLoading] = useState(false);\n    const [done, setDone] = useState(false);\n    const [data, setData] = useState<any>(config.initialData ?? null);\n    const [error, setError] = useState<any>(null);\n    const settings = {\n        deps: config.deps || [],\n        initialData: config.initialData || null,\n        autoLoad: config.autoLoad || false,\n    };\n    const reset = (disableAutoLoad = false) => {\n        setDone(false);\n        setLoading(false);\n        setError(null);\n        setData(settings.initialData);\n        disableAutoLoad && (settings.autoLoad = false)\n    };\n    const reload = useCallback((...realDeps: any[]) => {\n        if (loading) return;\n        // Abort the previous request if exists\n        abortControllerRef.current?.abort();\n        abortControllerRef.current = new AbortController();\n        setLoading(true);\n        setDone(false);\n        setError(null);\n        setData(settings.initialData);\n        // If realDeps are not provided, use settings.deps instead\n        const deps = realDeps.length > 0 ? realDeps : settings.deps;\n        const depsKey = JSON.stringify(deps);\n        if (cache.current.has(depsKey)) {\n            setData(cache.current.get(depsKey));\n            setLoading(false);\n            setDone(true);\n            return;\n        }\n        callback(...deps, { signal: abortControllerRef.current.signal })\n            .then((responseData: any) => {\n                setData(responseData);\n                setError(null);\n                setLoading(false);\n                setDone(true);\n                cache.current.set(depsKey, responseData);\n            })\n            .catch((err: any) => {\n                if (err.name === 'AbortError') return; // Ignore aborted requests\n                setError(err);\n                setData(settings.initialData);\n                setLoading(false);\n                setDone(false)\n            })\n    }, [settings.deps, callback]);\n    useEffect(() => {\n        settings.autoLoad && reload(...settings.deps);\n    }, [settings.autoLoad, reload, settings.deps]);\n    return { data, loading, error, done, reload, reset };\n};\nexport default useAsync\n// const useAsync: UseAsyncType = (_callback: Function, _config: UseAsyncConfig = {}) => {\n//     const empty = {\n//         loading: false,\n//         done: false,\n//         error: null,\n//         data: null,\n//         reload: () => {},\n//         reset: () => {}\n//     }\n//     if(!_callback) return empty;\n//     const settings = useMemo(() => { return {\n//         deps: _config.deps                       ?? [],\n//         initialData: _config.initialData         ?? null,\n//         autoLoad: _config.autoLoad               ?? false\n//     }}, [_config])\n//     const [loading, setLoading] = useState(false)\n//     const [done, setDone] = useState(false)\n//     const [data, setData] = useState<any>(settings.initialData)\n//     const [error, setError] = useState<any>(null)\n//     const isLoading = useRef(false)\n//     const wasInit = useRef(false)\n//     const depsAtStart = useRef<any>(null)\n//     const reset = () => {\n//         setDone(false)\n//         setLoading(false)\n//         setError(null)\n//         setData(settings.initialData)\n//     }\n//     const reload = useCallback((realDeps) => {\n//         if(loading || isLoading.current) return;\n//         isLoading.current = true\n//         setDone(false)\n//         setLoading(true)\n//         setError(null)\n//         setData(settings.initialData)\n//         _callback(...settings.deps)\n//             .then((data:any) => {\n//                 if(loading || isLoading.current) return;\n//                 setData(data)\n//                 setError(null)\n//                 // log('useAsync | data:', data)\n//             })\n//             .catch((err:any) => {\n//                 if(loading || isLoading.current) return;\n//                 setError(err)\n//                 // log('useAsync | error:', err)\n//                 setData(settings.initialData)\n//             })\n//             .finally(()=>{\n//                 if(loading || isLoading.current) return;\n//                 setLoading(false)\n//                 setDone(true)\n//                 // log('useAsync | done:', true)\n//                 isLoading.current = false\n//                 // console.log(`comparing deps:`, realDeps, depsAtStart.current)\n//                 // if(JSON.stringify(realDeps) !== JSON.stringify(depsAtStart.current)){\n//                 //     console.log(`Deps dont match...`)\n//                 //     reload(depsAtStart.current)\n//                 // }\n//             })\n//     }, [...settings.deps, _callback])\n//     useEffect(() => {\n//         settings.autoLoad && reload(settings.deps)\n//     }, [])\n//     useEffect(() => {\n//         console.log('>> Reload '+settings.deps)\n//         depsAtStart.current = settings.deps\n//         reload(settings.deps)\n//     }, [JSON.stringify(settings.deps)])\n//     return {data, loading, error, done, reload, reset}\n// }\n// ...\n// const useAsync: UseAsyncType = (_callback: Function, _config: UseAsyncConfig = {}) => {\n//     const settings = useMemo(() => { return {\n//         deps: _config.deps                       ?? [],\n//         initialData: _config.initialData         ?? null,\n//         autoLoad: _config.autoLoad               ?? false\n//     }}, [_config])\n//     const [loading, setLoading] = useState(false)\n//     const [done, setDone] = useState(false)\n//     const [data, setData] = useState<any>(settings.initialData)\n//     const [error, setError] = useState<any>(null)\n//     const isLoading = useRef(false)\n//     const reset = () => {\n//         setDone(false)\n//         setLoading(false)\n//         setError(null)\n//         setData(settings.initialData)\n//     }\n//     const reload = useCallback((realDeps) => {\n//         if (isLoading.current) return;\n//         isLoading.current = true;\n//         // Rest of the code...\n//         _callback(...settings.deps)\n//         .then((data: any) => {\n//             if (isLoading.current) return;\n//             // Rest of the code...\n//         })\n//         .catch((err: any) => {\n//             if (isLoading.current) return;\n//             // Rest of the code...\n//         })\n//         .finally(() => {\n//             if (isLoading.current) return;\n//             // Rest of the code...\n//         });\n//     }, [settings.deps, _callback]); // Fixed dependencies\n//     useEffect(() => {\n//         const cleanup = () => { isLoading.current = false; }; // Added cleanup function\n//         settings.autoLoad && reload(settings.deps);\n//         return cleanup; // Returning cleanup function\n//     }, [settings.autoLoad, settings.deps, reload]); // Fixed dependencies\n//     return {data, loading, error, done, reload, reset};\n// };\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// import { useCallback, useEffect, useRef, useState } from 'react';\n// type UseAsyncConfig = {\n//     initialData?: any;\n//     autoLoad?: boolean;\n//     deps?: any[];\n// };\n// type UseAsyncReturn = {\n//     loading: boolean;\n//     done: boolean;\n//     error: any;\n//     data: any;\n//     reload: Function;\n//     reset: Function;\n// };\n// type UseAsyncType = (callback: (...args: [...any[], AbortSignal]) => Promise<any>, config?: UseAsyncConfig) => UseAsyncReturn;\n// const useAsync: UseAsyncType = (callback, config = {}) => {\n//     const cache = useRef<Map<string, any>>(new Map());\n//     const abortControllerRef = useRef<AbortController | null>(null);\n//     const [loading, setLoading] = useState(false);\n//     const [done, setDone] = useState(false);\n//     const [data, setData] = useState<any>(config.initialData);\n//     const [error, setError] = useState<any>(null);\n//     const settings = {\n//         deps: config.deps || [],\n//         initialData: config.initialData || null,\n//         autoLoad: config.autoLoad || false,\n//     };\n//     const reset = () => {\n//         setDone(false);\n//         setLoading(false);\n//         setError(null);\n//         setData(settings.initialData);\n//     };\n//     const reload = useCallback((...realDeps: any[]) => {\n//         if (loading) return;\n//         // Abort the previous request if exists\n//         abortControllerRef.current?.abort();\n//         abortControllerRef.current = new AbortController();\n//         setLoading(true);\n//         setDone(false);\n//         setError(null);\n//         setData(settings.initialData);\n//         const depsKey = JSON.stringify(realDeps);\n//         if (cache.current.has(depsKey)) {\n//             setData(cache.current.get(depsKey));\n//             setLoading(false);\n//             setDone(true);\n//             return;\n//         }\n//         callback(...realDeps, abortControllerRef.current.signal)\n//             .then((responseData: any) => {\n//                 setData(responseData);\n//                 setError(null);\n//                 setLoading(false);\n//                 setDone(true);\n//                 cache.current.set(depsKey, responseData);\n//             })\n//             .catch((err: any) => {\n//                 if (err.name === 'AbortError') return; // Ignore aborted requests\n//                 setError(err);\n//                 setData(settings.initialData);\n//                 setLoading(false);\n//             });\n//     }, [settings.deps, callback]);\n//     useEffect(() => {\n//         settings.autoLoad && reload(...settings.deps);\n//     }, [settings.autoLoad, reload, settings.deps]);\n//     return { data, loading, error, done, reload, reset };\n// };\n// export default useAsync;\n"
  },
  "useCalculator.tsx": {
    "title": "useCalculator",
    "description": "??",
    "doc": "",
    "content": "import React, { useState, useEffect, useCallback } from 'react'\ntype Operator = {\n    type: string; // 'basic' | 'currency' | 'time' | etc.\n    symbol: string;\n    description?: string;\n    operation: (...args:number[]) => number;\n}\ntype OperatorMap = { [key:string]: Operator }\ntype UseCalculatorConfig = {\n    \n    customOperators?: OperatorMap;\n}\ntype UseCalculatorReturn = any\ntype UseCalculator = (config: UseCalculatorConfig) => UseCalculatorReturn\ntype N = number\ntype HistoryMap = { [key:string]: number }\nconst providedOperators: OperatorMap = {\n    'addition':{\n        type: 'basic',\n        symbol: '+',\n        operation: (a:N,b:N) => a + b\n    },\n    'subtraction':{\n        type: 'basic',\n        symbol: '-',\n        operation: (a:N,b:N) => a - b\n    }\n}\nconst useCalculator:UseCalculator = (config: UseCalculatorConfig = {}) => {\n    const [result, setResult] = useState<number | null>(null)\n    const [operandA, setOperandA] = useState<number | null>(null)\n    const [operandB, setOperandB] = useState<number | null>(null)\n    const [history, setHistory] = useState<HistoryMap>({})\n    const operatorMap: OperatorMap = providedOperators\n    Object.assign(operatorMap, config.customOperators)\n    const operators: {[key:string]: (...args:any[]) => number} = {}\n    Object.entries(operatorMap).forEach(([name, obj]) => {\n        operators[name] = obj.operation\n    })\n    return {\n        result,\n        history,\n        operatorMap,\n        operandA,\n        operandB,\n        setOperandA,\n        setOperandB,\n    }\n}\nexport default useCalculator\n/*\n+ WHAT CHANGES:\n- language\n- decimal seperator: 1,000.00 vs 1.000,00\n- \n+ COMMON FEATURES\n- basic math\n- conversions:\n    - currencies\n    - fractions\n- undo/redo\n- clear\n+ UX\n- use last value on operand when no primary operator input\n+ HISTORY\n- \"timstamp:::full_operation_string\" => result number\n*/"
  },
  "useClamp copy.tsx": {
    "title": "useClamp copy",
    "description": "??",
    "doc": "",
    "content": "import { useState, useEffect, SetStateAction } from 'react';\nconst useClamp: UseClamp.Hook = (config: UseClamp.Config = {}): UseClamp.Return => {\n    // Deconstruct values from config with default values\n    const { min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER, value = 0 } = config;\n    const [stateMin, setMinState] = useState(min);\n    const [stateMax, setMaxState] = useState(max);\n    const [expectedValue, setExpectedValue] = useState(value);\n    // Function to calculate the clamped value based on min, max, and expected value\n    const clampValue = (value: number) => {\n        return Math.min(Math.max(value, stateMin), stateMax);\n    };\n    const [clampedValue, setClampedValue] = useState(() => clampValue(expectedValue));\n    const handleClamp = (cb: SetStateAction<number>) => {\n        let res = typeof cb === 'function' ? cb(clampedValue) : cb;\n        setExpectedValue(res);\n        setClampedValue(clampValue(res));\n    }\n    useEffect(() => {\n        setClampedValue(clampValue(expectedValue));\n    }, [expectedValue, stateMin, stateMax]);\n    useEffect(() => setMinState(min), [min]);\n    useEffect(() => setMaxState(max), [max]);\n    useEffect(() => setExpectedValue(value), [value]);\n    // Function to reset the value to its initial state\n    const reset = () => {\n        setExpectedValue(value);\n        setClampedValue(clampValue(value));\n    };\n    return {\n        value: clampedValue,\n        setValue: handleClamp,\n        reset,\n        min: stateMin,\n        max: stateMax,\n        setMin: setMinState, // Function to set a new minimum bound\n        setMax: setMaxState, // Function to set a new maximum bound\n        initialValue: value,\n        expectedValue,\n    };\n};\nexport namespace UseClamp {\n    export type Config = {\n        min?: number;\n        max?: number;\n        value?: number;\n    }\n    export type Return = {\n        value: number;\n        setValue: (cb: SetStateAction<number>) => void;\n        reset: () => void;\n        min: number;\n        max: number;\n        setMin: (min: number) => void;\n        setMax: (max: number) => void;\n        initialValue: number;\n        expectedValue: number;\n    }\n    export interface Hook {\n        (config: Config): Return;\n    }\n}\nexport default useClamp;\n"
  },
  "useClamp.tsx": {
    "title": "useClamp",
    "description": "Clamp integer state within dynamic ranges",
    "doc": "/**\n * [useClamp](https://hooks.pratiq.dev/docs/hooks/useClamp)\n * \n * Clamp integer state within dynamic ranges\n * ________________________________________________________________________\n * @param\n * | type       | keys                  | description                           |\n * |:--         |:--                    |:--                                    |\n * | `object`   | **[config]**          | Config object (optional)              |\n * | `number`   | **[config.min]**      | The minimum clamping value (optional) |\n * | `number`   | **[config.max]**      | The maximum clamping value (optional) |\n * | `number`   | **[config.value]**    | The initial value to clamp (optional) |\n * \n * @returns \n * | type                   | keys              | description                       |\n * |:--                     |:--                |:--                                |\n * | `object`               | **value**         | The returned object               |\n * | `number`               | **value**         | The clamped value                 |\n * | `(n:number) => void`   | **setValue**      | Function to set clamped value     |\n * |                        | **reset**         | Function to reset value           |\n * |                        | **min**           | Minimum clamping value            |\n * |                        | **max**           | Maximum clamping value            |\n * |                        | **setMin**        | Function to set new minimum bound |\n * |                        | **setMax**        | Function to set new maximum bound |\n * |                        | **initialValue**  | Initial value of the clamping     |\n * |                        | **expectedValue** | Expected value of the clamping    |\n * ________________________________________________________________________\n * @interface\n * ```\n * export namespace UseClamp {\n *   export type Config = {\n *     min?: number;\n *     max?: number;\n *     value?: number;\n *   }\n *\n *   export type Return = {\n *     value: number;\n *     setValue: (cb: SetStateAction<number>) => void;\n *     reset: () => void;\n *     min: number;\n *     max: number;\n *     setMin: (min: number) => void;\n *     setMax: (max: number) => void;\n *     initialValue: number;\n *     expectedValue: number;\n *   }\n *\n *   export interface Hook {\n *     (config: Config): Return;\n *   }\n * }\n * ```\n * ________________________________________________________________________\n * @example\n * const clamp = useClamp({ min: 1, max: 10, value: 5 })\n * <button onClick={() => clamp.setValue(12)}>Clamp Value</button>\n */",
    "content": "import { useState, useEffect, SetStateAction } from 'react';\nconst useClamp: UseClamp.Hook = (config: UseClamp.Config = {}): UseClamp.Return => {\n    // Deconstruct values from config with default values\n    const { min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER, value = 0 } = config;\n    const [stateMin, setMinState] = useState(min);\n    const [stateMax, setMaxState] = useState(max);\n    const [expectedValue, setExpectedValue] = useState(value);\n    // Function to calculate the clamped value based on min, max, and expected value\n    const clampValue = (value: number) => {\n        return Math.min(Math.max(value, stateMin), stateMax);\n    };\n    const [clampedValue, setClampedValue] = useState(() => clampValue(expectedValue));\n    const handleClamp = (cb: SetStateAction<number>) => {\n        let res = typeof cb === 'function' ? cb(clampedValue) : cb;\n        setExpectedValue(res);\n        setClampedValue(clampValue(res));\n    }\n    useEffect(() => {\n        setClampedValue(clampValue(expectedValue));\n    }, [expectedValue, stateMin, stateMax]);\n    useEffect(() => setMinState(min), [min]);\n    useEffect(() => setMaxState(max), [max]);\n    useEffect(() => setExpectedValue(value), [value]);\n    // Function to reset the value to its initial state\n    const reset = () => {\n        setExpectedValue(value);\n        setClampedValue(clampValue(value));\n    };\n    return {\n        value: clampedValue,\n        setValue: handleClamp,\n        reset,\n        min: stateMin,\n        max: stateMax,\n        setMin: setMinState, // Function to set a new minimum bound\n        setMax: setMaxState, // Function to set a new maximum bound\n        initialValue: value,\n        expectedValue,\n    };\n};\nexport namespace UseClamp {\n    export type Config = {\n        min?: number;\n        max?: number;\n        value?: number;\n    }\n    export type Return = {\n        value: number;\n        setValue: (cb: SetStateAction<number>) => void;\n        reset: () => void;\n        min: number;\n        max: number;\n        setMin: (min: number) => void;\n        setMax: (max: number) => void;\n        initialValue: number;\n        expectedValue: number;\n    }\n    export interface Hook {\n        (config: Config): Return;\n    }\n}\nexport default useClamp;\n"
  },
  "useClickOutside.tsx": {
    "title": "useClickOutside",
    "description": "Handle click events outside of referenced elements",
    "doc": "/**\n * [useClickOutside](https://hooks.pratiq.dev/docs/hooks/useClickOutside)\n * \n * Handle click events outside of referenced elements\n * ________________________________________________________________________\n * @param\n * | type | keys | description |\n * |:--|:--|:--|\n * | `function` | **callback** | The callback function to invoke\n * \n * @returns \n * | type | keys | description |\n * |:--|:--|:--|\n * | `RefObject` | **clickOut** | A function used as a react ref for adding the current element\n * ________________________________________________________________________\n * @interface\n * ```\n * export interface I_UseCountdownConfig {   //  example\n *   duration?: number;                        //  10_000\n *   interval?: number;                        //  100\n *   callbacks?: { [key: string]: Function };  //  { 5000: () => fn() }\n * }\n * \n * export interface I_CountdownTimeObject {\n *   days: number;\n *   hours: number;\n *   minutes: number;\n *   seconds: number;\n *   realSeconds: number;\n *   milliseconds: number;\n *   total: number;\n * }\n * \n * export interface I_UseCountdownReturn{\n *   time: <I_CountdownTimeObject>;\n *   start: Function;\n *   stop: Function;\n *   reset: Function;\n *   done: boolean;\n *   started: boolean;\n *   running: boolean;\n *   interval: number;\n *   duration: number;\n * };\n * ```\n * ________________________________________________________________________\n * @example\n * const [isOpen, setIsOpen] = useState<boolean>(false)\n * const clickOut = useClickOutside(() => setIsOpen(false) )\n * <button ref={clickOut}>Open</button>\n */",
    "content": "import React, { useCallback, useEffect, useMemo, useRef } from 'react'\nimport { isBrowser } from '@pratiq/utils'\nconst useClickOutside: UseClickOutside.Hook = (callback: UseClickOutside.Callback): UseClickOutside.Return => {\n    if(!isBrowser()) return () => {};\n    const refArr:any[] = []\n    const handler = (e: MouseEvent) => {\n        console.log(`Running handler...`)\n        refArr.every(ref => !ref || !ref.contains(e.target)) && callback(e)\n    }\n    const clickOut = (el:any) => {\n        refArr.push(el)\n    }\n    useEffect(() => {\n        window.addEventListener('click', handler)\n        return () => window.removeEventListener('click', handler)\n    })\n    return clickOut\n}\nexport namespace UseClickOutside {\n    export type Callback = (e: MouseEvent) => any;\n    export type Return = (el: any) => unknown;\n    export interface Hook {\n        (callback: Callback): Return;\n        (callback: Callback, someOption: boolean): Return; // An overload with an additional parameter\n        // Add more overloads as needed...\n    }\n}\nexport default useClickOutside"
  },
  "useClipboard.tsx": {
    "title": "useClipboard",
    "description": "??",
    "doc": "",
    "content": "import {useEffect, useState} from 'react'\nimport {isBrowser} from '@pratiq/utils';\n    \nconst useClipboard = (initialValue:string = '', flashTime: number = 1000): UseClipboardReturn => {\n    const [value, setValue] = useState(initialValue)\n    const [success, setSuccess] = useState(false)\n    const [flash, setFlash] = useState(false)\n    if(!isBrowser() || !navigator?.clipboard){\n        console.log('no browser or clipboard:', { navigator, isBrowser: isBrowser() })\n        return {\n            copy: () => {},\n            value: '',\n            success: false,\n            flash: false,\n            reset: () => {}\n        }\n    }\n    const readFromClipboard = async () => {\n        try {\n            // Bypass TypeScript's type checking by using \"as any\"\n            const text = await navigator.clipboard.readText();\n            return text;\n        } catch (err) {\n            console.error('Failed to read from clipboard. Some environments support writing, but not reading from the clipboard.');\n            return null;\n        }\n    }\n    const copyToClipboard = async (text: string = ''): Promise<boolean> => {\n        try{\n            console.log('writing text:', text)\n            await navigator.clipboard.writeText(text)\n            // const permissionStatus = await navigator.permissions.query({ name: 'clipboard-read' } as any);\n            let val = await readFromClipboard() ?? text\n            console.log('new text:', val)\n            setSuccess(true)\n            setValue(val)\n            setFlash(true)\n            setTimeout(() => {\n                setFlash(false)\n            }, flashTime)\n            return true\n        }catch(err){\n            console.log('clipboard error:', err)\n            setSuccess(false)\n            return false\n        }\n    }\n    const reset = () => {\n        navigator.clipboard.writeText('')\n        setValue('')\n        setSuccess(false)\n    }\n    return {\n        copy:copyToClipboard, \n        value, \n        success, \n        reset,\n        flash,\n    }\n}\nexport type UseClipboardReturn = {\n    value: string;\n    copy: Function;\n    success: boolean;\n    flash: boolean;\n    reset: Function;\n}\nexport default useClipboard"
  },
  "useCookie.tsx": {
    "title": "useCookie",
    "description": "??",
    "doc": "",
    "content": "import {useEffect, useState} from 'react'\nimport { isBrowser } from '@pratiq/utils'\nimport debug from 'debug'\nconst log = debug('@pq:useCookie')\nconst useCookie = (key: string, initialValue?: string) => {\n    const empty = [\n        null,\n        () => {},\n        () => {}\n    ]\n    if (!isBrowser()) return empty\n    const [value, setValue] = useState(initialValue ?? '')\n    const getCookie = () => {\n        log('getCookie')\n        let name = key + \"=\";\n        let decodedCookie = decodeURIComponent(document.cookie);\n        let ca = decodedCookie.split(';');\n        for(let i = 0; i <ca.length; i++) {\n            let c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1);\n            }\n            if (c.indexOf(name) === 0) {\n                log('getCookie | return:', c.substring(name.length, c.length))\n                return c.substring(name.length, c.length);\n            }\n        }\n        log('getCookie | return: \"\"')\n        return \"\";\n    }\n    const handleCookie = (value: string, expiration: number = 86_400_000) => {\n        const d = new Date();\n        d.setTime(d.getTime() + (expiration));\n        let expires = \"expires=\"+d.toUTCString();\n        document.cookie = key + \"=\" + value + \";\" + expires + \";path=/; SameSite=None; Secure;\"\n        setValue(getCookie)\n    }\n    const removeCookie = () => {\n        document.cookie = key + '=; Max-Age=-99999999; path=/; SameSite=None; Secure;\"'; \n        setValue(getCookie())\n    }\n    useEffect(()=>{\n        setValue(getCookie())\n    }, [])\n    return [\n        value, \n        handleCookie, \n        removeCookie\n    ]\n}\nexport default useCookie"
  },
  "useCountdown.tsx": {
    "title": "useCountdown",
    "description": "??",
    "doc": "",
    "content": "import React, { useState, useEffect, useRef, useMemo } from \"react\";\nimport { isBrowser } from '@pratiq/utils'\nimport debug from 'debug'\nconst log = debug('@pq:useCookie')\nexport interface I_UseCountdownConfig {\n  duration: number;\n  interval?: number;\n  callbacks?: { [key: string]: Function };\n}\nexport interface I_UseCountdownSettings {\n  duration: number;\n  interval: number;\n  callbacks: { [key: string]: Function };\n}\nexport interface I_CountdownTimeObject {\n  days: number;\n  hours: number;\n  minutes: number;\n  seconds: number;\n  realSeconds: number;\n  milliseconds: number;\n  total: number;\n}\nexport interface I_UseCountdownReturn {\n  time: I_CountdownTimeObject;\n  status: T_UseCountdownStatus;\n  start: Function;\n  stop: Function;\n  reset: Function;\n  done: boolean;\n  started: boolean;\n  running: boolean;\n  interval: number;\n  duration: number;\n};\nexport type T_UseCountdownStatus = \n'ready' // the timer has NOT started yet\n| 'run' // the timer is running (!done, started)\n| 'idle' // the timer is stopped (!done, started, !running)\n| 'done' // the timer is done (done, started, !running)\nconst useCountdown = (config: I_UseCountdownConfig = { duration: 10_000 }): I_UseCountdownReturn => {\n  \n  \n  const settings: I_UseCountdownSettings = useMemo(() => {\n    let interval:number = 100;\n    if (config.interval) {\n      if (config.interval > 1000) interval = 1000;\n      else if (config.interval < 1) interval = 1;\n      else interval = config.interval;\n    }\n    return {\n      duration: config.duration ?? 10000,\n      callbacks: config.callbacks ?? {},\n      interval\n    };\n  }, [config]);\n  const createTimeObj = (t:number) => {\n    let ss = Math.floor(t / 1000);\n    return{\n      days: Math.floor(ss / 3600 / 24) % 24,\n      hours: Math.floor(ss / 3600) % 24,\n      minutes: Math.floor(ss / 60) % 60,\n      seconds: ss % 60,\n      realSeconds: Math.ceil(t / 1000),\n      milliseconds: t % 1000,\n      total: t\n    } \n  }\n  \n  const [timeObj, setTimeObj] = useState<any>(() => createTimeObj(settings.duration))\n  \n  const [ticking, setTicking] = useState<boolean>(false);\n  \n  \n  const [time, setTime] = useState<number>(settings.duration);\n  \n  \n  const [initialStartTime, setInitialStartTime] = useState<number>(0);\n  \n  \n  const [stopTime, setStopTime] = useState<number>(0);\n  \n  \n  const [totalStopTime, setTotalStopTime] = useState<number>(0);\n  \n  \n  const [done, setDone] = useState<boolean>(false);\n  \n  \n  const [started, setStarted] = useState<boolean>(false);\n  \n  \n  const [cbs, setCbs] = useState<any>({});\n  \n  \n  const tRef = useRef<any>(null);\n  const [stopFireTime, setStopFireTime] = useState<number>(0);\n  const [status, setStatus] = useState<T_UseCountdownStatus>('ready')\n  \n  \n  const handleCountdown = () => {\n    // if (!ticking) return;\n    tRef.current = setTimeout(() => {\n    // First find the actual time elapsed while timer was ticking by subtract\n    //    initalStartTime from now and subtract the totalStopTime to account\n    //    for pausing.\n    // Subtract this value from settings.duration to find the current state\n    //    of the timer\n    const diffTime =\n        settings.duration - (Date.now() - initialStartTime - totalStopTime);\n    // If diffTime is greater than or equal to 0, setTime to diffTime and if\n    //    ticking is still true, call this function again.\n    if (diffTime >= 0) {\n      let s = Math.floor(diffTime / 1000);\n      \n      \n      setTimeObj(() => createTimeObj(diffTime));\n      setTime(diffTime);\n      if (ticking) handleCountdown();\n    } else {\n      // If the diffTime is less than 0, set ticking to false, clear the\n      //    timeout and set time to 0\n      setTimeObj({\n        days: 0,\n        hours: 0,\n        minutes: 0,\n        seconds: 0,\n        realSeconds: 0,\n        milliseconds: 0,\n        total: 0\n      });\n      clearTimeout(tRef.current);\n      setDone(true);\n      setTime(0);\n      setTicking(false);\n      if (\"end\" in cbs && cbs[\"end\"].ran === false) {\n        cbs[\"end\"].func();\n        cbs[\"end\"].ran = true;\n      }\n    }\n    }, settings.interval);\n  };\n  \n  useEffect(() => {\n      if (ticking) handleCountdown();\n  }, [ticking]);\n  \n  useEffect(() => {\n    if (\n      Object.entries(cbs).length === 0 &&\n      config.callbacks &&\n      Object.entries(config.callbacks).length > 0\n    ) {\n    // log(\"found callbacks:\", config.callbacks);\n    const newCbs: any = {};\n    settings.callbacks && Object.entries(settings.callbacks).forEach((cb: any) => {\n        newCbs[cb[0]] = {\n        ran: false,\n        func: cb[1]\n        };\n    });\n    // log(\"accumulated callbacks:\", cbs);\n    setCbs(newCbs);\n    }\n  }, [settings.callbacks, cbs]);\n    \n  useEffect(() => {\n      if (time === settings.duration) return;\n      // log(\"time...\");\n      for (const [key] of Object.entries(cbs)) {\n      if (time <= parseInt(key) && cbs[key].ran === false) {\n          cbs[key].func();\n          cbs[key].ran = true;\n          // log(\"a cb ran:\", cbs[key]);\n      }\n      }\n  }, [time, cbs]);\n  useEffect(()=>{\n    setStatus(() => {\n      if(done) return 'done' \n      else if (ticking) return 'run' // !done && !ticking\n      else if (started) return 'idle'\n      return 'ready'\n    })\n  },[done, started, ticking, time])\n  \n  const start = () => {\n      if (!ticking && !done) setTicking(true);\n      if (!started && !done) setStarted(true);\n      if (!initialStartTime) setInitialStartTime(Date.now());\n      if (\"start\" in cbs && cbs[\"start\"].ran === false) {\n        cbs[\"start\"].func();\n        cbs[\"start\"].ran = true;\n      }\n      if (stopTime) {\n        setTotalStopTime((t: number) => t + (Date.now() - stopTime));\n        setStopTime(0);\n      }\n    };\n  \n  const stop = () => {\n    setStopFireTime(\n      settings.duration - (Date.now() - initialStartTime - totalStopTime)\n    );\n    setTicking(false);\n    clearTimeout(tRef.current);\n    if (!stopTime) setStopTime(Date.now());\n    };\n  \n  const reset = () => {\n    setTimeObj(() => createTimeObj(settings.duration));\n    setTicking(false);\n    setInitialStartTime(0);\n    setTime(settings.duration);\n    clearTimeout(tRef.current);\n    setStarted(false);\n    setDone(false);\n    setStopTime(0);\n    setTotalStopTime(0);\n    for (const [key] of Object.entries(cbs)) {\n      cbs[key].ran = false;\n    }\n  };\n  return {\n    time: timeObj,\n    start,\n    stop,\n    reset,\n    done,\n    started,\n    running: ticking,\n    status,\n    // stopFireTime,\n    // cbs,\n    interval: settings.interval,\n    duration: settings.duration\n  };\n};\nexport default useCountdown;\n/*\n * \n * @example\n * const { \n *  time,                           // current state of the countdown timer\n *  done,                           // is the countdown done\n *  running,                        // is the timer running\n *  started,                        // has the timer started\n *  start,                          // start the countdown\n *  stop,                           // stop (pause) the countdown\n *  reset,                          // reset state to initial values\n * } = useCountdown({\n *  duration: 10_000,               // total duration of the countdown\n *  interval: 10,                   // time (ms) between time refresh\n *  callbacks: {                    // object containing callback functions\n *    'start':() => log('started')  // invoked when timer started\n *    'end':  () => log('over')     // invoked when timer reaches 0\n *    7000:   () => log('7000ms')   // invoked at 7000ms (time state)\n *    3000:   () => log('3000ms')   // invoked at 3000ms (time state)\n *  },\n * })\n*/"
  },
  "useCssVariables.tsx": {
    "title": "useCssVariables",
    "description": "??",
    "doc": "",
    "content": "import {useState, useCallback, useEffect} from 'react'\n    \nexport type RefOrElement = HTMLElement | React.RefObject<HTMLElement>\nexport type UseCssVariablesConfig = {\n    \n    match?: string;\n    \n    element?: RefOrElement;\n}\nexport type UseCssVariablesReturn = [\n    \n    css: { [key:string]: string },\n    \n    setCss: (variables: Record<string, string>) => void,\n    \n    update: () => void,\n]\nconst useCssVariables = (match: string = '', element?: RefOrElement): UseCssVariablesReturn => {\n    const [css, setCss] = useState({})\n    const refresh = useCallback(() => {\n        let el: any;\n        if(element){\n            if('current' in element){\n                el = element.current\n            }else{\n                el = element\n            }\n        }\n        else{\n            if(typeof document !== 'object' || !('documentElement' in document)) return [{}, () => {}]\n            el = element ?? document.documentElement\n        }\n        if(match === ''){\n            setCss(getComputedStyle(el))\n        }else{\n            const cssMap:any = {}\n            \n            Object.values(getComputedStyle(el))\n            .filter(item => item.includes(match))\n            .forEach(item => { cssMap[item] = getComputedStyle(el).getPropertyValue(item) })\n            \n            setCss(cssMap)\n        }\n    }, [match])\n    const set = useCallback((variables) => {\n        if(!variables || typeof variables !== 'object') return;\n        const el: any = element && 'current' in element \n            ? element.current \n            : element ?? document.documentElement;\n        Object.keys(variables).forEach((key) => {\n            el.style.setProperty(key, variables[key]);\n        });\n    }, [element]);\n    \n    useEffect(() => {\n        refresh()\n    }, [match])\n    return [\n        css, \n        setCss,\n        refresh\n    ]\n}\nexport default useCssVariables"
  },
  "useDebounceEffect.tsx": {
    "title": "useDebounceEffect",
    "description": "??",
    "doc": "",
    "content": "import {useRef, useCallback, useEffect} from 'react'\nconst useDebounceEffect = (callback: () => unknown, dependencies: any[] = [], delay: number = 250, maxWait?: number):void => {\n    const callbackRef = useRef<any>(callback)\n    const timeoutRef = useRef<any>()\n    const eventualRef = useRef<any>()\n    const handleEventual = () => {\n        if(!maxWait || typeof maxWait !== 'number') return;\n        if(!eventualRef.current){\n            eventualRef.current = setTimeout(()=>{\n                callbackRef.current()\n                timeoutRef.current && clearTimeout(timeoutRef.current)\n                eventualRef.current && clearTimeout(eventualRef.current)\n                eventualRef.current = null\n            }, maxWait)\n        }\n    }\n    const set = useCallback(()=>{\n        clear()\n        handleEventual()\n        timeoutRef.current = setTimeout(()=>{\n            callbackRef.current()\n            eventualRef.current && clearTimeout(eventualRef.current)\n            eventualRef.current = null\n        }, delay)\n    }, [delay])\n    \n    const clear = useCallback(()=>{\n        timeoutRef.current && clearTimeout(timeoutRef.current)\n    }, [])\n    \n    const reset = useCallback(() => {\n        clear()\n        set()\n    }, [clear, set])\n    useEffect(()=>{\n        callbackRef.current = callback\n    }, [callback])\n    useEffect(() => {\n        set()\n        return clear()\n    }, [delay, set, clear])\n    useEffect(clear)\n    useEffect(reset, [...dependencies, reset])\n    useEffect(set, dependencies)\n}\nexport default useDebounceEffect"
  },
  "useDynamic.tsx": {
    "title": "useDynamic",
    "description": "??",
    "doc": "",
    "content": "import React, { Suspense, useState, useEffect, useMemo, lazy, useRef } from 'react';\nimport { isBrowser } from '@pratiq/utils'\nimport debug from 'debug'\nconst log = debug('@pq:useCookie')\nfunction renderLazyComponent(component:string) {\n    //~ FOR DEMO PURPOSES ONLY                  \n    //~ REMOVE INTENTIONAL DELAY\n    return lazy(() => {\n        return new Promise(resolve => {\n          setTimeout(() => resolve(import('./' + component)), 1_500);\n        });\n    });\n    //   return lazy(() => import(component + ''))\n}\ntype UseDynamicComponents = {\n    [key:string | number]: string;\n}\ntype UseDymamicOptions = {\n    default?: string | number;\n    preload?: Array<string | number>;\n    fallback?: React.ReactNode;\n}\ntype UseDynamic = (list: UseDynamicComponents, options: UseDymamicOptions) => ({\n    Component: React.JSXElementConstructor<any>;\n    next: () => void;\n    prev: () => void;\n    goto: (path: string | number) => void;\n    index: number;\n    names: string[];\n    name: string;\n})\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nconst useDynamic: UseDynamic = (list: {[key:string]:string}, options: UseDymamicOptions = {}) => {\n    const settings = useMemo(() => ({\n        defaultIndex: options?.default          ? options.default       : 0,\n        preload: options?.preload               ??                      [],\n        fallback: options?.fallback             ?? <p>Loading...</p>\n    }), [options])\n    \n    const [index, setIdx] = useState<number>(0)\n    const compMap = useRef<any>({})\n    const preloadRef = useRef<any>(false)\n    const entries:any = useMemo(() => Object.entries(list), [list])\n    const length:any = useMemo(() => Object.entries(list).length, [list])\n    const names:string[] = useMemo(() => Object.keys(list), [list])\n    const name:string = useMemo(() => Object.keys(list)[index], [list, index])\n    const next = (N:number = 1) => setIdx(n => n + N < length ? n + N : 0)\n    const prev = (N:number = 1) => setIdx(n => n - N >= 0 ? n - N : length - 1)\n    const setIndex = (N:number = 0) => setIdx(n => (N >= 0 && N <= length - 1) ? N : n)\n    const goto = (path:string | number) => {\n        if(typeof path === 'string'){\n           if(names.includes(path)){\n                setIndex(names.findIndex((el => el === path)))\n           }\n        }else if(typeof path === 'number'){\n            setIndex(path)\n        }\n    }\n    \n    //&                                                                                             \n    const preload = () => {\n        if(preloadRef.current) return;\n        preloadRef.current = true\n         \n        settings.preload.forEach(preloadKey => {\n            if(!(entries[preloadKey][0] in compMap.current)){\n                console.log(`>>  ${preloadKey} | no component - render component ${preloadKey}`)\n                compMap.current[entries[preloadKey][0]] = renderLazyComponent(entries[preloadKey][1])\n            }\n        })\n    }\n    //&                                                                                             \n    const Comp = useMemo(() => {\n        if(!(entries[index][0] in compMap.current)){\n            console.log(`>>  ${index} | no component - render component ${index}`)\n            compMap.current[entries[index][0]] = renderLazyComponent(entries[index][1])\n            preload()\n            return compMap.current[entries[index][0]]\n        }else{\n            console.log('>> component found - return comp')\n            return compMap.current[entries[index][0]]\n        }\n    }, [index, entries])\n    \n    //&                                                                                             \n    const Component = () => \n        <Suspense fallback={settings.fallback ?? <>Loading {index} ...</>}>\n            <Comp />\n        </Suspense>\n    //&                                                                                             \n    // update the index to the default\n    useEffect(()=>{\n        console.log('>>> DIR:', )\n        console.log(list, options)\n        setIdx((currentIndex:number) => {\n            return typeof settings.defaultIndex === 'number'\n            ? settings.defaultIndex\n            : typeof settings.defaultIndex === 'string'\n                ? Object.keys(list).indexOf(settings.defaultIndex) ?? 0\n                : 0\n        })\n    }, [])\n    //&                                                                                             \n    if(!list || typeof window === 'undefined') return {\n        Component: () => null,\n        next: () => {},\n        prev: () => {},\n        goto: () => {},\n        index:0,\n        names: [],\n        name: '',\n    }\n    //&                                                                                             \n    return {\n        Component,\n        next,\n        prev,\n        goto,\n        index,\n        names,\n        name,\n    }\n}\nexport default useDynamic\n"
  },
  "useEnvironment.tsx": {
    "title": "useEnvironment",
    "description": "??",
    "doc": "",
    "content": "import { useEffect, useState } from 'react';\n// function useEnvironment({ checkWindowObject = false } = {}) {\n//     const [isClient, setIsClient] = useState(false);\n//     const [isBrowser, setIsBrowser] = useState(false);\n//     useEffect(() => {\n//         // Check for client-side (non-SSR)\n//         setIsClient(true);\n//         // If configured to check for the window object, do so\n//         if (checkWindowObject) {\n//             setIsBrowser(typeof window === 'object');\n//         }\n//     }, [checkWindowObject]);\n//     return checkWindowObject ? isBrowser : isClient;\n// }\n// // Usage for checking client-side\n// const isClient = useEnvironment();\n// // Usage for checking browser's window object\n// const isBrowser = useEnvironment({ checkWindowObject: true });\n// import { useEffect, useState } from 'react';\nfunction useEnvironment() {\n    const [environment, setEnvironment] = useState({\n        hasWindow: false,\n        hasDocument: false,\n        isTouchDevice: false,\n        isOnline: false,\n        viewportSize: { width: 0, height: 0 },\n        supportsCookies: false,\n        prefersDarkMode: false,\n        supportsGeolocation: false,\n        supportsFileApi: false,\n        supportsWebGL: false,\n        supportsNotifications: false,\n        grantedNotifications: false\n    });\n    useEffect(() => {\n        const updateEnvironment = async () => {\n            let grantedNoti = typeof navigator === 'object' \n                ? (await navigator?.permissions?.query({ name: 'geolocation' })).state === 'granted'\n                    ? true\n                    : false\n                : false\n            setEnvironment({\n                hasWindow: typeof window === 'object',\n                hasDocument: typeof document === 'object',\n                isTouchDevice: 'ontouchstart' in window || navigator.maxTouchPoints > 0,\n                isOnline: navigator.onLine,\n                viewportSize: {\n                    width: window.innerWidth,\n                    height: window.innerHeight,\n                },\n                supportsCookies: navigator.cookieEnabled,\n                prefersDarkMode: window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches,\n                supportsGeolocation: 'geolocation' in navigator,\n                supportsFileApi: 'FileReader' in window,\n                supportsWebGL: (() => {\n                    try {\n                        const canvas = document.createElement('canvas');\n                        return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\n                    } catch (e) {\n                        return false;\n                    }\n                })(),\n                supportsNotifications: 'Notification' in window,\n                grantedNotifications: grantedNoti   \n            });\n        };\n        updateEnvironment();\n        // Optional: Update on specific events like resize, online/offline status change\n        window?.addEventListener?.('resize', updateEnvironment);\n        window?.addEventListener?.('online', updateEnvironment);\n        window?.addEventListener?.('offline', updateEnvironment);\n        return () => {\n            window?.removeEventListener?.('resize', updateEnvironment);\n            window?.removeEventListener?.('online', updateEnvironment);\n            window?.removeEventListener?.('offline', updateEnvironment);\n        };\n    }, []);\n    return environment;\n}\nexport default useEnvironment"
  },
  "useErrorBoundary.tsx": {
    "title": "useErrorBoundary",
    "description": "??",
    "doc": "",
    "content": "import React, { useState, useEffect, useRef, useMemo } from 'react'\n// TODO: create a standard component that has the same features\ntype ErrorHandler = (error: Error, info: React.ErrorInfo) => void\ntype ErrorHandlingComponent<Props> = (props: Props, error?: Error) => React.ReactNode\ntype ErrorState = { error?: Error }\nfunction Catch<Props extends {}>(\n  component: ErrorHandlingComponent<Props>,\n  errorHandler?: ErrorHandler\n): React.ComponentType<Props> {\n  return class extends React.Component<Props, ErrorState> {\n    state: ErrorState = {\n      error: undefined\n    }\n    \n    static getDerivedStateFromError(error: Error) {\n      return { error }\n    }\n    \n    componentDidCatch(error: Error, info: React.ErrorInfo) {\n      console.log('componentDidCatch: error:', error)\n      if (errorHandler) {\n        errorHandler(error, info)\n      }\n    }\n    \n    render() {\n      return component(this.props, this.state.error)\n    }\n  }\n}\ntype T_UseErrorBoundaryConfig = {\n    children?: React.ReactNode;\n    fallback?: React.JSXElementConstructor<any>;\n    handleError?: ErrorHandler;\n    handleReset?: Function;\n}\ntype T_UseErrorBoundary = (config?: T_UseErrorBoundaryConfig) => React.JSXElementConstructor<any>\nconst DefaultErrorComponent = (props: any) => (\n    <div className=\"error-screen\" style={{color: '#000 !important', background: '#f888', padding: '1rem'}}>\n        <p style={{color: '#000', fontWeight: 'bold'}}>Error boundary caught an error:</p>\n        <pre style={{fontSize: '.8rem', padding: '.2rem  .4rem'}}>{props?.error?.message ?? props?.error ?? 'No error message'}</pre>\n        {props?.resetErrorBoundary && <button onClick={() => props.resetErrorBoundary()}>Reset</button>}\n    </div>\n)\nconst useErrorBoundary: T_UseErrorBoundary = (config: T_UseErrorBoundaryConfig = {}) => {\n    const errStateRef = useRef(0)\n    const errContentRef = useRef<any>(null)\n    const child = useMemo(() => config.children, [config.children])\n    const handleReset = () => {\n        if(config.handleReset){\n            config.handleReset()\n        }\n    }\n    useEffect(()=>{\n      console.log('errorBoundary state change...')\n    })\n      \n    return Catch((props: T_UseErrorBoundaryConfig, error?: Error) => {\n        if (error) {\n            errContentRef.current = error\n            if(config.fallback){\n                errStateRef.current = 1\n                return <config.fallback \n                          error={error} \n                          resetErrorBoundary={handleReset}\n                        />\n            }else{\n                errStateRef.current = 2\n                return <DefaultErrorComponent \n                          error={error} \n                          resetErrorBoundary={handleReset}\n                        />\n            }\n        \n        } \n        \n        else {\n            errStateRef.current = 0\n            return <React.Fragment>{props.children}</React.Fragment>\n        }\n    }, config.handleError)\n}\nexport default useErrorBoundary"
  },
  "useEventListener.tsx": {
    "title": "useEventListener",
    "description": "??",
    "doc": "",
    "content": "import React, {useRef, useEffect, useState} from 'react'\nimport { isBrowser } from '@pratiq/utils'\nimport debug from 'debug'\nconst log = debug('@pq:useEventListener')\n    \ntype T_UseEventListener = (event:string, callback:Function, element: any) => [\n    isEnabled:boolean,\n    toggle: () => void\n]\nconst useEventListener: T_UseEventListener = (event: string, callback: Function, element: any) => {\n    if(!isBrowser()) return [false, () => {}];\n    \n    const [hasListener, setHasListener] = useState(false)\n    \n    const callbackRef = useRef<any>(callback)\n    const handlerRef = useRef<any>(null)\n    const elementRef = useRef<any>(null)\n    const removeListener = () => {\n        try{\n            if(elementRef.current && handlerRef.current && callbackRef.current){\n                elementRef.current.removeEventListener(event, handlerRef.current)\n            }\n            setHasListener(false)\n        }catch(err){}\n    }\n    const addListener = () => {\n        try{\n            if(!element && typeof window !== 'undefined'){ element = window }\n            else{ return; }\n            elementRef.current = element\n            handlerRef.current = (e: Event) => callbackRef.current(e)\n            elementRef.current.addEventListener(event, handlerRef.current)\n            setHasListener(true)\n        }catch(err){}\n    }\n    const toggle = () => hasListener ? removeListener() : addListener()\n    const listen = useRef((element: any) => {\n        if (!element) return;\n        elementRef.current = element;\n        addListener();\n    });\n    \n    useEffect(() => {\n        callbackRef.current = callback\n    }, [callback])\n    useEffect(() => {\n        removeListener()\n        addListener()\n        return () => elementRef.current.removeEventListener(event, handlerRef.current)\n    }, [event, element])\n    return [ hasListener, toggle ]\n}\nexport default useEventListener"
  },
  "useFetch.tsx": {
    "title": "useFetch",
    "description": "??",
    "doc": "",
    "content": "import {useState, useRef, useEffect, useMemo, useCallback} from 'react'\nimport { isBrowser } from '@pratiq/utils'\nimport debug from 'debug'\nconst log = debug('@pq:useFetch')\nexport type UseFetchConfig = {\n    watch?: any[];\n    expire?: number;\n    options?: Record<string, any>;\n    initialData?: any;\n    autoLoad?: boolean;\n}\nexport type UseFetchSettings = {\n    watch: any[];\n    expire: number;\n    options: Record<string, any>;\n    initialData: any;\n    autoLoad: boolean;\n}\n// Cache object outside the hook\nconst cache: Record<string, { data: any; timestamp: number }> = {};\nconst useFetch = (url: string = '', config: UseFetchConfig) => {\n    log('useFetch v0.2')\n    const {\n        options, watch, expire, initialData, autoLoad\n    }:UseFetchSettings = useMemo(() => ({\n        options: config.options ?? {},\n        watch: config.watch ?? [],\n        expire: config.expire ?? 5_000,\n        initialData: config.initialData ?? null,\n        autoLoad: config.autoLoad ?? true,\n    }), [config]);\n    const [loading, setLoading] = useState(false);\n    const [loaded, setLoaded] = useState(false);\n    const [error, setError] = useState<any>(null);\n    const [data, setData] = useState<any>(initialData);\n    const done = useRef(true);\n    const abortController = useRef(new AbortController());\n    const expireHandle: any = useRef();\n    const cacheKey = useMemo(() => `${url}_${expire}_${JSON.stringify(watch)}_${JSON.stringify(options)}`, [url, watch, options, expire]);\n    // log('cacheKey:', cacheKey)\n    const handleExpire = () => {\n        if (!done.current) {\n            log('Force expiring request...')\n            clearTimeout(expireHandle.current);\n            setError(`Request expired. Expiration set to ${expire} ms`);\n            setData(initialData);\n            setLoading(false);\n            setLoaded(false);\n            done.current = true;\n        }\n    };\n    const errorIntercept = (response: any) => {\n        log('Error intercept:', response)\n        if (!response.ok) {\n            setError(response.statusText);\n            done.current = true;\n        }\n        return response;\n    };\n    const handleError = (e: any) => {\n        if (!done.current) {\n            log('handleError:', e)\n            clearTimeout(expireHandle.current);\n            done.current = true;\n            setError(e);\n            setLoading(false);\n            setLoaded(false);\n        }\n    };\n    const handleValue = (v: any) => {\n        if (!done.current) {\n            log('handleValue:', v)\n            clearTimeout(expireHandle.current);\n            cache[cacheKey] = { data: v, timestamp: Date.now() }; // Cache the response\n            done.current = true;\n            setData(v);\n            setError(undefined);\n            setLoading(false);\n            setLoaded(true);\n        }\n    };\n    const reset = () => {\n        log('resetting...')\n        abortController.current.abort();\n        abortController.current = new AbortController();\n        setLoaded(false);\n        setLoading(false);\n        setError(null);\n        setData(initialData);\n    };\n    const reload = useCallback(() => {\n        log('reloading...')\n        if (!done.current) {\n            log('NOT DONE: abort and clear timeout')\n            abortController.current.abort();\n            abortController.current = new AbortController();\n            clearTimeout(expireHandle.current);\n        }\n        log('Continuing to reload...')\n        setLoading(true);\n        setLoaded(false);\n        setError(null);\n        setData(initialData);\n        done.current = false;\n        // Check cache\n        const cachedData = cache[cacheKey];\n        if (cachedData) {\n            log('Checking cache...')\n            if (Date.now() - cachedData.timestamp < expire) {\n                log('>>> Cache hit:', cacheKey)\n                setData(cachedData.data); // Set cached data if available and not expired\n                setLoading(false)\n                setLoaded(true)\n                setError(null)\n                done.current = true\n                return\n            }\n            // delete expired entries\n            log('>>> Cache miss:', cacheKey)\n            // delete cache[cacheKey]\n        } \n        // setLoading(true);\n        // setLoaded(false);\n        // setError(null);\n        // setData(initialData);\n        expireHandle.current = setTimeout(handleExpire, expire); // Set expiration timeout\n        try {\n            options.signal = abortController.current.signal;\n            log('Running fetch:', url)\n            fetch(url, { ...options, signal: abortController.current.signal })\n                .then(errorIntercept)\n                .then(res => res.json())\n                .then(res => {\n                    log('Request success. setting cache, state and clearing timeouts', res)\n                    cache[cacheKey] = { data: res, timestamp: Date.now() }\n                    clearTimeout(expireHandle.current);\n                    handleValue(res);\n                    done.current = true\n                })\n                .catch(err => {\n                    if (err.name !== 'AbortError') handleError(err);\n                });\n        } catch (err) {\n            if ((err as any).name !== 'AbortError') handleError(err);\n        }\n    }, [url, expire, options]); // Include the dependencies that the `reload` function relies on\n    useEffect(() => {\n        autoLoad && reload();\n        return () => {\n            abortController.current.abort();\n            clearTimeout(expireHandle.current);\n        };\n    }, [reload, autoLoad]);\n    return { data, loading, loaded, error, reload, reset };\n};\nexport default useFetch;\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// const defaultOptions = {\n//     headers: {\n//         \"Content-Type\":\"application/json\",\n//         \"Access-Control-Allow-Origin\": \"*\"\n//     }, \n// }\n// export interface I_UseFetch {\n//     watch?: any[];\n//     expire?: number;\n//     options?: object;\n//     initialData?: any;\n//     autoLoad?: boolean;\n// }\n// const useFetch_original = (url: string = '', config: I_UseFetch) => {\n    \n//     const settings: = useMemo(() => ({\n//         options: config.options         ?? {},\n//         watch: config.watch             ?? [],\n//         expire: config.expire           ?? 5_000,\n//         initialData: config.initialData ?? null,\n//         autoLoad: config.autoLoad       ?? true,\n//     }), [config])\n//     const [loading, setLoading] = useState(false)\n//     const [loaded, setLoaded] = useState(false)\n//     const [error, setError] = useState<any>(null)\n//     const [data, setData] = useState<any>(initialData)\n//     let done = useRef(true)\n//     let init = useRef(false)\n//     let triggerSignalRef = useRef<any>(null)\n//     let watchRef = useRef<any>(null)\n//     let abortRef = useRef<any>(new AbortController())\n//     let expireHandle: any = useRef()\n//     // const abort_ctrl = new AbortController()\n//     //@ts-ignore\n//     // options.signal = abort_ctrl.signal\n//     // sigRef.current = abort_ctrl.signal\n//     const handleExpire = () => {\n//         if(!done.current){\n//             clearTimeout(expireHandle.current)\n//             setError(`Request expired. Expiration set to ${expire} ms`)\n//             setData(initialData)\n//             setLoading(false)\n//             setLoaded(false)\n//             done.current = true\n//         }\n//     }\n//     function errorIntercept(response: any) {\n//         if (!response.ok) {\n//             setError(response.statusText)\n//             done.current = true\n//         }\n//         return response;\n//     }\n    \n//     const handleError = (e: any) => {\n//         if(!done.current){\n//             clearTimeout(expireHandle.current)\n//             done.current = true\n//             try{\n//                 if(e && e instanceof TypeError){ setError(e.message)}\n//                 else if(e && typeof e === 'object'){ setError(e) }\n//                 else if(e){ setError(e) }\n//                 else{ setError(true) }\n//             }catch(err){\n//                 setError(true)\n//                 setData(initialData)\n//             }finally{ \n//                 setLoading(false)\n//                 setLoaded(false)\n//             }\n//         }\n//     }\n//     const handleValue = (v: any) => {\n//         if(!done.current){\n//             clearTimeout(expireHandle.current)\n//             done.current = true\n//             setData(v)\n//             setError(undefined)\n//             setLoading(false)\n//             setLoaded(true)\n//         }\n//     }\n//     const reset = () => {\n//         setLoaded(false)\n//         setLoading(false)\n//         setError(null)\n//         setData(initialData)\n//     }\n//     const reload = () => {\n//         // if(!done.current){\n//         //     abortRef.current.abort()\n//         //     abortRef.current = new AbortController()\n//         //     clearTimeout(expireHandle.current)\n//         // }\n//         watchRef.current = JSON.stringify(watch)\n//         done.current = false\n//         log('reload')\n//         clearTimeout(expireHandle.current)\n//         expireHandle.current = setTimeout(handleExpire, expire);\n//         setLoading(true)\n//         setLoaded(false)\n//         setError(null)\n//         setData(initialData)\n//         // log('reload...', watch, url)\n        \n//         try{\n//             //@ts-ignore\n//             options.signal = abortRef.current.signal\n//             fetch(url, options)\n//             .then(errorIntercept)\n//             .then(res => {\n//                 if (res && res.ok) { return res.json() }\n//                 else if(!res){ handleError('No response') }\n//             })\n//             .then(res => {\n//                 if(watchRef.current !== JSON.stringify(watch)){\n//                     // log('mismatch:', {ref: watchRef.current, watch: watch})\n//                     // abortRef.current.abort()\n//                     clearTimeout(expireHandle.current)\n//                 }else{\n//                     handleValue(res)\n//                 }\n//             })\n//             .catch(err => {\n//                 handleError(err)\n//             })\n//         }catch(err){ \n//             handleError(err) \n//         }\n//     }\n    \n//     useEffect(() => {\n//         if(!init.current) return;\n//         log('useFetch | use effect')\n//         // if(abort_ctrl){\n//             // abort_ctrl.abort()\n//         // }\n//         reload()\n        \n//         return () => clearTimeout(expireHandle.current)\n//         // eslint-disable-next-line\n//     }, watch)\n//     useEffect(()=>{\n//         log('autoload')\n//         autoLoad && reload()\n//         init.current = true\n//     },[])\n//     return {data, loading, loaded, error, reload, reset}\n// }\n// export default useFetch\n/*\n--------------------------------------------------------------------- CHANGELOG\n- converted return object to an array and altered order of return values\n- altered config interface to allow optional values\n- added default config object with empty string url\n-------------------------------------------------------------------------- TODO\n! loaded\n- consider adding loaded boolean state to return\n! initialData\n- consider adding initialData item to config, with reset function provided in \n- return object to reset state to initial values\n! config.autoLoad: boolean\n- consider adding a config flag for autoLoad that can prevent the request from\n- loading until the user invokes `reload` function\n? should loading / reloading remove the current state?\n> this would prevent old data from showing while loading... makes sense for now \n*/"
  },
  "useGeolocation.tsx": {
    "title": "useGeolocation",
    "description": "??",
    "doc": "",
    "content": "import {useState, useEffect, useRef, useMemo} from 'react'\nimport { isBrowser } from '@pratiq/utils'\nimport debug from 'debug'\nconst log = debug('@pq:useGeolocation')\nexport interface I_UseGeoOptions {\n    \n    maximumAge?: number;\n    \n    timeout?: number;\n    \n    enableHighAccuracy?: boolean;\n}\nexport type UseGeoData = {         // example\n    accuracy: number | null;            // 5000 \n    altitudeAccuracy: number | null;    // null\n    heading: number | null;                    // 55.115156546655356,       \n    latitude: number | null;                   // 43.210 \n    longitude: number | null;                  // -87.654 \n    speed: number | null;                      // 0 \n    timestamp: number | null;                  // 1234567890987, \n    delta: number | null;                      // 842 \n    direction: string | null;           // 'NNW'\n} \nexport type UseGeoReturn = {\n    data: UseGeoData;\n    error: any;\n    active: boolean;\n}\nconst useGeolocation = (options: I_UseGeoOptions = {}):UseGeoReturn => {\n    const nullData: UseGeoData = {\n        accuracy: null,\n        altitudeAccuracy: null,\n        heading: null,\n        direction: null,\n        latitude: null,\n        longitude: null,\n        speed: null,\n        timestamp: null,\n        delta: null,\n    }\n    if (!isBrowser()) return { data:nullData, error: null, active: false } \n    const [error, setError] = useState<any>(null)\n    const [data, setData] = useState<UseGeoData>(nullData)\n    const [isActive, setIsActive] = useState(false)\n    const lastTime = useRef<any>(Date.now())\n    const getDirectionFromHeading = (heading: number) => {\n        let map: { [key:number | string]: string } = {\n            0: 'N',\n            22.5:'NNE',\n            45: 'NE',\n            67.5: 'ENE',\n            90: 'E',\n            112.5: 'ESE',\n            135: 'SE',\n            157.5: 'SSE',\n            180: 'S',\n            202.5: 'SSW',\n            225: 'SW',\n            247.5: 'WSW',\n            270: 'W',\n            292.5: 'WNW',\n            315: 'NW',\n            337.5: 'NNW',\n            360: 'N',\n        }\n        let headings = Object.keys(map)\n        var closest: string = headings.reduce((previousValue: string, currentValue: string, currentIndex: number, array: string[]):string => {\n            let prev = parseFloat(previousValue)\n            let curr = parseFloat(currentValue)\n            return (Math.abs(curr - heading) < Math.abs(prev - heading) ? curr : prev).toString();\n          });\n        return map[closest]\n    }\n    useEffect(()=>{\n        const successHandler = (e: any) => {\n            setError(null)\n            setIsActive(true)\n            const {\n                accuracy,\n                altitudeAccuracy,\n                heading,\n                latitude,\n                longitude,\n                speed,\n            } = e.coords;\n            let delta = e.timestamp - lastTime.current\n            lastTime.current = e.timestamp\n            setData({\n                accuracy,\n                altitudeAccuracy,\n                heading,\n                direction: getDirectionFromHeading(heading),\n                latitude,\n                longitude,\n                speed,\n                timestamp: e.timestamp,\n                delta\n            })\n        }\n        \n        const errorHandler = (e:any) => {\n            log('error:',e)\n            setError(e.message)\n            setData(nullData)\n            setIsActive(false)\n        }\n        navigator.geolocation.getCurrentPosition(\n            successHandler,\n            errorHandler,\n            options\n        )\n        const id = navigator.geolocation.watchPosition(\n            successHandler,\n            errorHandler,\n            options\n        )\n        return () => navigator.geolocation.clearWatch(id)\n    }, Object.values(options))\n    return {data, error, active:isActive}\n}\nexport default useGeolocation"
  },
  "useIDB.tsx": {
    "title": "useIDB",
    "description": "??",
    "doc": "",
    "content": "import {useState, useCallback, useEffect, useMemo} from 'react'\nexport interface I_UseDBReturn {\n  value: any; \n  setValue: (value:any) => void; \n  loading: boolean; \n  error: boolean;\n  reset: () => void;\n  remove: (key:string) => void;\n}\ntype T_UseIDBConfig = {\n  key?: string;\n  value?: any;\n  startWithValue?: boolean;\n}\ntype T_UseIDB = (config?: T_UseIDBConfig) => ({\n  value: any; \n  setValue: (value:any) => void; \n  loading: boolean; \n  error: boolean;\n  reset: () => void;\n  remove: (key:string) => void;\n})\nconst useIDB: T_UseIDB = (config: T_UseIDBConfig = {}) => {\n  const settings = useMemo(() => ({\n    storeKey:               config.key                      ?? Date.now(),\n    initialValue:           config.value                    ?? null,\n    startWithValue: config.startWithValue   ?? false\n  }),[config])\n  type UseStore = <T>(\n    txMode: IDBTransactionMode,\n    callback: (store: IDBObjectStore) => T | PromiseLike<T>,\n  ) => Promise<T>;\n  let defaultGetStoreFunc: UseStore | undefined;\n  const [reactStateValue, setReactStateValue] = useState<any>(settings.startWithValue ? settings.initialValue : null)\n  const [stateLoading, setStateLoading] = useState<boolean>(false)\n  const [stateError, setStateError] = useState<boolean>(false)\n  const safariFix = (): Promise<void> => {\n    let navigator: any = window.navigator\n    const isSafari =\n        !navigator.userAgentData &&\n        /Safari\\//.test(navigator.userAgent) &&\n        !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    if (!isSafari || !indexedDB.databases) return Promise.resolve();\n    let intervalId: any;\n    return new Promise<void>((resolve) => {\n        const tryIdb = () => indexedDB.databases().finally(resolve);\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(() => clearInterval(intervalId));\n  }  \n  const promisifyRequest = (request: IDBRequest | IDBTransaction): Promise<any> => {\n    return new Promise((resolve, reject) => {\n      // @ts-ignore - file size hacks\n      request.oncomplete = request.onsuccess = () => resolve(request.result);\n      // @ts-ignore - file size hacks\n      request.onabort = request.onerror = () => reject(request.error);\n    });\n  }\n  const createStore = useCallback((dbName: string, storeName: string): UseStore=>{\n    const dbp = safariFix().then(() => {\n      const request = indexedDB.open(dbName);\n      request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n      return promisifyRequest(request);\n    });\n    return (txMode, callback) =>\n      dbp.then((db: any) =>\n        callback(db.transaction(storeName, txMode).objectStore(storeName)),\n      );\n  }, [])\n  const defaultGetStore = useCallback(() => {\n    if (!defaultGetStoreFunc) {\n      defaultGetStoreFunc = createStore('keyval-store', 'keyval');\n    }\n    return defaultGetStoreFunc;\n  }, [])\n  const get:any = useCallback((key: IDBValidKey, customStore = defaultGetStore()): Promise<any> => {\n    return customStore('readonly', (store: any) => promisifyRequest(store.get(key)));\n  }, [defaultGetStore])\n  const set = (value: any, customStore = defaultGetStore()): Promise<void> => {\n    return customStore('readwrite', (store) => {\n        store.put(value, settings.storeKey);\n        return promisifyRequest(store.transaction);\n    });\n  }\n  const del = (customStore = defaultGetStore()): Promise<void> => {\n    setReactStateValue(undefined)\n    return customStore('readwrite', (store) => {\n      store.delete(settings.storeKey);\n      return promisifyRequest(store.transaction);\n    });\n  }\n  const setValueHandler = (val: any) => {\n    setStateLoading(true)\n    setStateError(false)\n    setReactStateValue(val)\n    set(val)\n      .then(() => setStateLoading(false))\n      .catch((e) => setStateError(e))\n  }\n  const resetValueHandler = () => {\n    setStateLoading(true)\n    setStateError(false)\n    setReactStateValue(settings.initialValue)\n    set(settings.initialValue)\n      .then(() => setStateLoading(false))\n      .catch((e) => setStateError(e))\n  }\n  const deleteValueHandler = () => {\n    setStateLoading(true)\n    setStateError(false)\n    setReactStateValue(null)\n    del()\n      .then(() => setStateLoading(false))\n      .catch((e) => setStateError(e))\n  }\n  useEffect(()=>{\n    setStateLoading(true)\n    get(settings.storeKey)\n    .then((v: any)=> { \n      if(typeof v !== 'undefined'){ setReactStateValue(v) }\n      else if(settings.startWithValue){ setReactStateValue(settings.initialValue) }\n      setStateLoading(false)\n    })\n    .catch((e:any)=>{\n      setStateError(e)\n      setStateLoading(false)\n    })\n  }, [get, settings.initialValue, settings.storeKey, setStateLoading])\n  const ret: I_UseDBReturn = {\n    value: reactStateValue, \n    setValue: setValueHandler, \n    loading: stateLoading, \n    error: stateError,\n    reset: resetValueHandler,\n    remove: deleteValueHandler\n  }\n  return ret\n}\nexport default useIDB"
  },
  "useInput.tsx": {
    "title": "useInput",
    "description": "??",
    "doc": "",
    "content": "import React, {useMemo, useState, useCallback, useEffect, useRef, CSSProperties } from 'react'\nimport { isBrowser } from '@pratiq/utils'\nimport debug from 'debug'\nconst log = debug('@pq:useInput')\n// const log = extend('local_useInput')\n// const log = console.log\nexport enum StyleGroupNames {\n    \n    DEFAULT = 'default',\n    DEFAULT_HOVER = 'default-hover',\n    DEFAULT_FOCUS = 'default-focus',\n    DEFAULT_ACTIVE = 'default-active',\n    \n    VALID = 'valid',\n    VALID_HOVER = 'valid-hover',\n    VALID_FOCUS = 'valid-focus',\n    VALID_ACTIVE = 'valid-active',\n    \n    INVALID = 'invalid',\n    INVALID_HOVER = 'invalid-hover',\n    INVALID_FOCUS = 'invalid-focus',\n    INVALID_ACTIVE = 'invalid-active',\n}\nexport type T_UseInputReturn = {\n    value: string;\n    setValue: (value:string) => void;\n    validate: () => void;\n    reset: () => void;\n    save: (value:string) => void;\n    remove: () => void;\n    \n    isValid: boolean;\n    isEmpty: boolean;\n    isHovered: boolean;\n    isFocused: boolean;\n    wasValidated: boolean;\n    invalidMessage: string;\n    bind: {\n        value: string;\n        style: { [key: string]: CSSProperties };\n        className: string;\n        type: string;\n        name: string;\n        readOnly: boolean;\n        disabled: boolean;\n        placeholder: string;\n        onFocus: (e:any) => void;\n        onBlur: (e:any) => void;\n        onMouseEnter: (e:any) => void;\n        onMouseLeave: (e:any) => void;\n        onMouseUp: (e:any) => void;\n        onMouseDown: (e:any) => void;\n        onReset: (e:any) => void;\n        onChange: (e:any) => void;\n        onClick: (e:any) => void;\n    },\n};\nexport type T_UseInputConfig = {\n    reset?: any;\n    \n    type?: string;\n    \n    name?: string;\n    \n    storageKey?: string;\n    \n    storageObject?: any;\n    \n    saveOnChange?: boolean;\n    \n    options?: string[];\n    styleGroup?: { [Property in StyleGroupNames]: { [key: string]: CSSProperties } };\n    style?: { [key: string]: CSSProperties };\n    className?: string;\n    value?: string;\n    placeholder?: string;\n    readOnly?: boolean;\n    disabled?: boolean;\n    invalidMessage?: string;\n    \n    validOnDefault?: boolean;\n    \n    validateOnBlur?: boolean;\n    \n    validateOnChange?: boolean;\n    validator?: (value: string) => boolean | RegExp | string;\n    onValidated?: (value: string) => void;\n    onActive?: (value: string) => void;\n    onHover?: (value: string) => void;\n    onFocus?: (value: string) => void;\n    onBlur?: (value: string) => void;\n}\ntype T_UseInput = (config?: T_UseInputConfig) => T_UseInputReturn;\nconst useInput:T_UseInput = (config: T_UseInputConfig = {}) => {\n    const empty = {\n        value: '',\n        setValue: () => {},\n        validate: () => {},\n        reset: () => {},\n        save: () => {},\n        remove: () => {},\n        \n        isValid: false,\n        isEmpty: false,\n        isHovered: false,\n        isFocused: false,\n        wasValidated: false,\n        invalidMessage: '',\n        bind: {\n            value: '',\n            style: {},\n            className: '',\n            type: 'text',\n            name: '',\n            readOnly: false,\n            disabled: false,\n            placeholder: '',\n            onFocus: () => {},\n            onBlur: () => {},\n            onMouseEnter: () => {},\n            onMouseLeave: () => {},\n            onMouseUp: () => {},\n            onMouseDown: () => {},\n            onReset: () => {},\n            onChange: () => {},\n            onClick: () => {},\n        },\n    };\n    if(!isBrowser()) return empty;\n    // log('og style:', config.style || {})\n    const getDefaultStyle = () => {\n        let res: { [key:string]: any } = config.styleGroup || {}\n        Object.values(StyleGroupNames).forEach((x, i) => {\n            if(!(x in res)){\n                res[x] = {}\n            }\n        })\n        // log('new style:', res)\n        return res\n    }\n    const settings = useMemo(() => ({\n        styleGroup:                                 getDefaultStyle(),\n        style: config.style                         ?? {},\n        storageObject: config.storageObject         ?? typeof window !== 'undefined' ? window.localStorage : null,\n        type: config.type                           ?? 'text',\n        name: config.name                           ?? '',\n        className: config.className                 ?? '',\n        value: config.value                         ?? '',\n        placeholder: config.placeholder             ?? '',\n        invalidMessage: config.invalidMessage       ?? '',\n        readOnly: config.readOnly                   ?? false,\n        disabled: config.disabled                   ?? false,\n        saveOnChange: config.saveOnChange           ?? false,\n        validOnDefault: config.validOnDefault       ?? false,\n        validateOnChange: config.validateOnChange   ?? false,\n        validateOnBlur: config.validateOnBlur       ?? false,\n        storageKey: config.storageKey               ?? null,\n        options: config.options                     ?? null,\n        validator: config.validator                 ?? null,\n        onActive: config.onActive                   ?? null,\n        onHover: config.onHover                     ?? null,\n        onFocus: config.onFocus                     ?? null,\n        onBlur: config.onBlur                       ?? null,\n        reset: config.reset                         ?? [],\n    }), [config])\n    //+ ///////////////////////////////////////////////////////////////// STATE\n    const [value, setValue] = useState(settings.value)\n    const [wasValidated, setWasValidated] = useState(false)\n    const [isValid, setIsValid] = useState(false)\n    const [invalidMessage, setInvalidMessage] = useState('')\n    const [isEmpty, setIsEmpty] = useState(value?.toString().length === 0)\n    const [isFocused, setIsFocused] = useState(false)\n    const [isHovered, setIsHovered] = useState(false)\n    const [isActive, setIsActive] = useState(false)\n    const [style, setStyle] = useState({})\n    const [className, setClassName] = useState(settings.className)\n    const initRef = useRef(false)\n    \n    //+ ///////////////////////////////////////////////////////////// FUNCTIONS\n    const handleValidate = useCallback(() => {\n        log('handleValidate')\n        setWasValidated(true)\n    \n        \n        if(settings.validator){\n            if(settings.validator instanceof RegExp){\n                let validatorResult = settings.validator.test(value)\n                setIsValid(validatorResult)\n                setInvalidMessage(validatorResult ? '' : settings.invalidMessage)\n            }else if(typeof settings.validator === 'function'){\n                let validatorResult = settings.validator(value) ? true : false\n                setIsValid(validatorResult)\n                setInvalidMessage(validatorResult ? '' : settings.invalidMessage)\n            }else{\n                let validatorResult = settings.validator === value\n                setIsValid(validatorResult)\n                setInvalidMessage(validatorResult ? '' : settings.invalidMessage)\n            }\n        }else if(settings.options && settings.options.length){\n            if(!settings.options.includes(value)){\n                if(value.length){\n                    setIsValid(false)\n                    setInvalidMessage(`Value \"${value}\" does not exist in options: ${settings.options.join(', ')}`)\n                }else{\n                    setIsValid(true)\n                    setInvalidMessage('')\n                }\n            }else{\n                setIsValid(true)\n                setInvalidMessage('')\n            }\n        }else{\n            setIsValid(true)\n            setInvalidMessage('')\n        }\n    }, [settings, value])\n    const handleReset = () => {\n        // shouldUpdate.current = true\n        log('handleReset')\n        setIsValid(settings.validOnDefault ? true : false)\n        setIsEmpty(value?.toString().length === 0)\n        setValue(settings.value)\n        setWasValidated(false)\n        setInvalidMessage('')\n        removeStorage()\n        initRef.current = false\n    }\n    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n        log('handleChange:', e.target.value)\n        if(settings.type === 'checkbox'){\n            setValue(e.target.checked.toString())\n        }\n        // else if(settings.options && settings.options.length){\n        //     settings.options.forEach((opt:string) => {\n        //         console.log(`Checking match: \"${e.target.value}\" => \"${opt}\"`)\n        //         let reg = new RegExp(e.target.value,'gm').test(opt)\n        //         if(reg){\n        //             console.log(`Match: \"${e.target.value}\" => \"${opt}\"`)\n        //             // setValue(opt)\n        //         }\n        //     })\n        // }\n        else{\n            setValue(e.target.value)\n        }\n    }\n    const getStorage = () => {\n        if(!shouldLoadStorage.current){\n            log('getStorage cancelled by: shouldLoadStorage.current = false')\n            return\n        }\n        log('getStorage')\n        if(!settings.storageObject || !settings.storageKey) return null;\n        const found = settings.storageObject.getItem(settings.storageKey)\n        if(found){\n            setValue(found)\n        }\n    }\n    \n    const setStorage = (value:string) => {\n        log('setStorage')\n        if(!settings.storageObject || !settings.storageKey) return;\n        settings.storageObject.setItem(settings.storageKey, value)\n    }\n    \n    const removeStorage = () => {\n        log('removeStorage')\n        if(!settings.storageObject || !settings.storageKey) return;\n        settings.storageObject.removeItem(settings.storageKey)\n    }\n \n    //+///////////////////////////////////////////////////////////////// EVENTS\n    \n    const onMouseEnter = () => {\n        log('onMouseEnter')\n        setIsHovered(true)\n        settings.onHover && settings.onHover(value)\n    }\n    \n    const onMouseLeave = () => {\n        log('onMouseLeave')\n        setIsHovered(false)\n        setIsActive(false)\n    }\n    \n    const onMouseUp = () => {\n        log('onMouseUp')\n        setIsActive(false)\n    }\n    \n    const onMouseDown = () => {\n        log('onMouseDown')\n        setIsActive(true)\n    }\n    \n    const onFocus = () => {\n        log('onFocus')\n        setIsFocused(true)\n        settings.onFocus && settings.onFocus(value)\n    }\n    \n    const onBlur = () => {\n        log('onBlur')\n        setIsFocused(false)\n        setIsHovered(false)\n        settings.onBlur && settings.onBlur(value)\n        settings.validateOnBlur && handleValidate()\n    }\n    //+ ///////////////////////////////////////////////////////////////// SETUP\n    useEffect(()=>{\n        // setting styles should go in order from least important to most\n        const handleClassVsStyle = (SGN: string, className?: string) => {\n            // if(typeof settings.style[SGN] === 'string'){\n            //     setClassName(settings.className + ' ' + settings.style[SGN])\n            //     setStyle(settings.rootStyle)\n            // }else{\n                setStyle({...settings.style, ...settings.styleGroup[SGN]})\n                setClassName(settings.className + ' ' + SGN.replace('-', ' '))\n            // }\n        }\n        \n        if(wasValidated){\n            if(isValid){\n                if(isFocused) handleClassVsStyle(StyleGroupNames.VALID_FOCUS) \n                if(isHovered) handleClassVsStyle(StyleGroupNames.VALID_HOVER)\n                if(isActive) handleClassVsStyle(StyleGroupNames.VALID_ACTIVE)\n                if(!isHovered && !isActive && !isFocused) handleClassVsStyle(StyleGroupNames.VALID)\n            }else{\n                if(isFocused) handleClassVsStyle(StyleGroupNames.INVALID_FOCUS) \n                if(isHovered) handleClassVsStyle(StyleGroupNames.INVALID_HOVER)\n                if(isActive) handleClassVsStyle(StyleGroupNames.INVALID_ACTIVE)\n                if(!isHovered && !isActive && !isFocused) handleClassVsStyle(StyleGroupNames.INVALID)\n            }\n            \n        }else{\n            if(isFocused) handleClassVsStyle(StyleGroupNames.DEFAULT_FOCUS) \n            if(isHovered) handleClassVsStyle(StyleGroupNames.DEFAULT_HOVER)\n            if(isActive) handleClassVsStyle(StyleGroupNames.DEFAULT_ACTIVE)\n            if(!isHovered && !isActive && !isFocused) handleClassVsStyle(StyleGroupNames.DEFAULT)\n        }\n    }, [isHovered, isFocused, isValid, isEmpty, isActive, wasValidated, value])\n    const shouldLoadStorage = useRef(true)\n    \n    \n    useEffect(()=>{\n        if(!initRef.current){\n            log('init...')\n            getStorage()\n            if(value === '' && settings.value){\n                setValue(settings.value)\n            }\n            handleValidate()\n        }else{\n            if(settings.validateOnChange){\n                handleValidate()\n            }\n            if(settings.saveOnChange){\n                setStorage(value)\n            }\n        } \n        \n        setIsEmpty(value.toString().length === 0)\n        log(settings.style)\n        \n        initRef.current = true\n    },[value, settings.validateOnChange, settings.saveOnChange])\n    //! Just changed this from 'useUpdateEffect'\n    useEffect(() => {\n        shouldLoadStorage.current = false\n        log('handleReset')\n        setIsValid(settings.validOnDefault)\n        setIsEmpty(value?.toString().length === 0)\n        setValue('')\n        setWasValidated(false)\n        setInvalidMessage('')\n        removeStorage()\n        initRef.current = false\n    }, [config.reset])\n    //+ //////////////////////////////////////////////////////////////// RETURN\n    return {\n        value,\n        setValue,\n        validate: handleValidate,\n        reset: handleReset,\n        save: setStorage,\n        remove: removeStorage,\n        \n        isValid,\n        isEmpty,\n        isHovered,\n        isFocused,\n        wasValidated,\n        invalidMessage: isValid ? '' : wasValidated ? invalidMessage : '',\n        bind: {\n            value,\n            style,\n            className,\n            type: settings.type,\n            name: settings.name,\n            readOnly: settings.readOnly,\n            disabled: settings.disabled,\n            placeholder: settings.placeholder,\n            onFocus,\n            onBlur,\n            onMouseEnter,\n            onMouseLeave,\n            onMouseUp,\n            onMouseDown,\n            onReset: handleReset,\n            onChange: (e:any) => handleChange(e),\n            onClick: (e:any) => handleChange(e),\n        },\n    };\n    \n    \n}\nexport default useInput"
  },
  "useInterval.tsx": {
    "title": "useInterval",
    "description": "??",
    "doc": "",
    "content": "import {useRef, useEffect, useCallback} from 'react'\nexport interface I_UseIntervalOptions {\n    autoStart?: boolean;\n    callbackOnClear?: boolean;\n}\nconst useInterval = (callback: any = () => {}, delay: number = 1000, options: I_UseIntervalOptions = {}) => {\n    const callbackRef = useRef(callback)\n    const intervalRef = useRef<any>()\n    const incrementRef = useRef(0)\n    useEffect(()=>{\n        callbackRef.current = callback\n    }, [callback])\n    const set = useCallback(()=>{\n        intervalRef.current = setInterval(()=>{\n            incrementRef.current = incrementRef.current + 1\n            callbackRef.current(incrementRef.current)\n        }, delay)\n    }, [delay])\n    \n    const clear = useCallback(()=>{\n        incrementRef.current = 0\n        intervalRef.current && clearInterval(intervalRef.current)\n    }, [])\n    useEffect(() => {\n        options?.autoStart && set()\n        return clear\n    }, [delay, set, clear])\n    const reset = useCallback(() => {\n        clear()\n        set()\n    }, [clear, set])\n    return { reset, stop: clear }\n};\nexport default useInterval"
  },
  "useKeyboard.tsx": {
    "title": "useKeyboard",
    "description": "??",
    "doc": "",
    "content": "import React, {useState, useCallback, useEffect, useMemo} from 'react'\nimport { isBrowser } from '@pratiq/utils'\nimport debug from 'debug'\nconst log = debug('@pq:useKeyboard')\n \nexport interface I_UseKeyboardConfig {\n    element?: any;\n    // listDom?: boolean;\n    minComboKeys?: number;\n    ignoreKeys?: string[];\n    maxHistory?: number;\n    combos?: { [key: string]: Function };\n    handleCombos?: Function;\n}\nconst useKeyboard = (config: I_UseKeyboardConfig = {}) => {\n    if (!isBrowser()) return;\n    const settings = useMemo(()=> ({\n        element: config.element             ?? window,\n        // listDom: config.listDom             ?? false,\n        minComboKeys: config.minComboKeys   ?? 2,\n        ignoreKeys: config.ignoreKeys       ?? [],\n        maxHistory: config.maxHistory       ?? 10,\n        combos: config.combos               ?? null,\n        handleCombos: config.handleCombos   ?? null,\n    }),[config])\n    const [_key, set_key] = useState<string | null>(null)\n    const [_lastKey, set_lastKey] = useState<string | null>(null)\n    const [_down, set_down] = useState<boolean>(false)\n    const [_repeat, set_repeat] = useState<boolean>(false)\n    const [_combo, set_combo] = useState<string | null>(null)\n    \n    const [_ctrl, set_ctrl] = useState<boolean>(false)\n    const [_alt, set_alt] = useState<boolean>(false)\n    const [_shift, set_shift] = useState<boolean>(false)\n    const [_space, set_space] = useState<boolean>(false)\n    const [_meta, set_meta] = useState<boolean>(false)\n    \n    const [_lastEvent, set_lastEvent] = useState<React.KeyboardEvent | null>(null)\n    const [_eventsArray, set_eventsArray] = useState<React.KeyboardEvent[]>([])\n    const [_history, set_history] = useState<React.KeyboardEvent[]>([])\n    // useEffect(()=>{\n    //     if(settings.maxHistory > 0 && _history.length > settings.maxHistory){\n    //         log('aaa', {\n    //             history: settings.maxHistory,\n    //             length: _history.length\n    //         })\n    //         _history.splice(0,1)\n    //         set_history(_history)\n    //     }\n    // },[_history])\n    useEffect(()=>{\n        settings.handleCombos && settings.handleCombos(_combo)\n    },[_combo])\n    /////////////////////////////////////////////////////////////////////\n    const cleanupKeys = () => {\n        set_key(null)\n        set_lastKey(null)\n        set_down(false)\n        set_repeat(false)\n        set_combo(null)\n        set_ctrl(false)\n        set_alt(false)\n        set_shift(false)\n        set_space(false)\n        set_meta(false)\n        set_lastEvent(null)\n        set_eventsArray([])\n    }\n    /////////////////////////////////////////////////////////////////////\n    const isNotIgnored = useCallback((e: any) => {\n        let usable = true\n        settings.ignoreKeys.forEach((k: string) => {\n            if(\n                k.toUpperCase() === e.key.toUpperCase() \n                || k.toUpperCase() === e.code.toUpperCase()\n            ){ usable = false }\n        })\n        return usable\n    }, settings.ignoreKeys)\n    /////////////////////////////////////////////////////////////////////\n    const handleCombos = () => {\n        \n        let dk = _eventsArray.map((e: any) => e?.code?.toUpperCase())\n        settings.combos && Object.entries(settings.combos).forEach((combo:any) => {\n            \n            // the callback function name split into an array\n            let funcNameSplit = \n                combo[0]\n                .toLowerCase()\n                .split('-')\n            // a string of all the keys pressed\n            let keyString = \n                dk\n                .join('-')\n                .replace(/CONTROLLEFT/g, 'CTRL')\n                .replace(/CONTROLRIGHT/g, 'CTRL')\n                .replace(/SHIFTLEFT/g, 'SHIFT')\n                .replace(/SHIFTRIGHT/g, 'SHIFT')\n                .replace(/ALTRIGHT/g, 'ALT')\n                .replace(/ALTLEFT/g, 'ALT')\n                .replace(/ARROW/g, '')\n                .replace(/KEY/g, '')    \n                .replace(/DIGIT/g, '')\n                .replace(/NUMPAD/g, '')\n                .toLowerCase()\n            let match = 0\n            funcNameSplit.forEach((funcKey: string, i:number) => {\n                keyString.split('-').forEach((pressKey: string, j:number) => {\n                    if(funcKey === pressKey) {\n                        match++\n                    }\n                })\n            })\n            if(match === funcNameSplit.length){\n                combo[1]()\n            }\n            \n        })\n    }\n    /////////////////////////////////////////////////////////////////////\n    const keySwitch = useCallback(() => {\n        \n        let dk = _eventsArray.map((e: any) => e?.code?.toUpperCase())\n        set_lastEvent(_eventsArray[_eventsArray.length - 1])\n        set_down( dk.length > 0 ? true : false )\n        set_key(dk[dk.length - 1] || null)\n        set_lastKey(dk[dk.length - 1] ? dk[dk.length - 1] : _lastKey)\n        set_ctrl(dk.toString().match(/CONTROL/) ? true : false)\n        set_shift(dk.toString().match(/SHIFT/) ? true : false)\n        set_alt(dk.toString().match(/ALT/) ? true : false)\n        set_meta(dk.toString().match(/META/) ? true : false)\n        set_space(dk.toString().match(/SPACE/) ? true : false)\n        \n        if(dk.length >= settings.minComboKeys){\n            set_combo(dk.toString())\n        }\n        else{\n            set_combo(null)\n        }\n    }, [_ctrl, _alt, _eventsArray, _lastKey, settings.minComboKeys])\n    \n    /////////////////////////////////////////////////////////////////////\n    const downHandler = useCallback((e: any) => {\n        if(e.repeat){ \n            set_repeat(true)\n            return \n        }else{\n            set_repeat(false)\n        }\n        if(isNotIgnored(e)){\n            set_eventsArray((existingEvents: any[]) => [...existingEvents, e])\n            set_history((currentHistory: React.KeyboardEvent[]) => {\n                if(settings.maxHistory > 0 && currentHistory.length >= settings.maxHistory){\n                    currentHistory.splice(0,1)\n                    return [...currentHistory, e]\n                }else{\n                    return [...currentHistory, e]\n                }\n            })  \n        }\n    }, [isNotIgnored])\n    /////////////////////////////////////////////////////////////////////\n    const upHandler = useCallback((e: any) => {\n        set_repeat(false)\n        set_eventsArray((existingEvents: any[])  => \n            [...existingEvents.filter(\n                    event => event?.code?.toUpperCase() !== e.code.toUpperCase() \n                )\n            ]\n        )\n    }, [])\n    /////////////////////////////////////////////////////////////////////\n    const onVisChange = () => {\n        if(document.visibilityState === 'hidden' || document.hidden){\n            set_eventsArray([])\n        }\n    }\n    const onBlurOrFocusLost = () => { set_eventsArray([]) }\n    /////////////////////////////////////////////////////////////////////\n    // event handlers \n    useEffect(() => {\n        keySwitch()\n    }, [_eventsArray])\n    useEffect(() => {\n        handleCombos()\n    }, [_history])\n    useEffect(()=> { \n        return cleanupKeys\n    } ,[])\n    useEffect(() => {\n        settings.element.addEventListener('keydown', downHandler)\n        settings.element.addEventListener('keyup', upHandler)\n        document.addEventListener(\"visibilitychange\", onVisChange);\n        document.addEventListener(\"blur\", onBlurOrFocusLost);\n        return () => {\n            settings.element.removeEventListener('keydown', downHandler)\n            settings.element.removeEventListener('keyup', upHandler)\n            document.removeEventListener(\"visibilitychange\", onVisChange);\n        }\n    }, [settings.element, downHandler, upHandler])\n    return { \n        events: _eventsArray, \n        down: _down, \n        ctrl: _ctrl, \n        key: _key, \n        lastKey: _lastKey,\n        lastEvent: _lastEvent,\n        alt: _alt, \n        shift: _shift, \n        meta: _meta, \n        repeat: _repeat, \n        combo: _combo, \n        space: _space,\n        history: _history,\n        reset: cleanupKeys,\n        clearHistory: () => set_history([])\n    }\n}\nexport default useKeyboard"
  },
  "useMediaQuery.tsx": {
    "title": "useMediaQuery",
    "description": "??",
    "doc": "",
    "content": "import {useState, useEffect} from 'react'\n//@ts-ignore\nimport { isBrowser } from '@pratiq/utils'\nimport debug from 'debug'\nconst log = debug('@pq:useMediaQuery')\ntype T_StringMap = { [key:string]: string }\ntype T_BooleanMap = { [key:string]: boolean }\ntype T_UseMediaQueryList = string | string[] | T_StringMap\ntype T_UseMediaQuerySelector = string | number | any[]\ntype T_UseMediaQuery = (mediaQueries: T_UseMediaQueryList) => boolean | T_UseMediaQueryGetter\ntype T_UseMediaQueryGetter = (selector?: T_UseMediaQuerySelector) => boolean | T_BooleanMap\nconst useMediaQuery:T_UseMediaQuery = (mediaQueries: T_UseMediaQueryList) => {\n    const [matchObj, setMatchObj] = useState<T_BooleanMap>({})\n    const itemAtIndex: (selector?: T_UseMediaQuerySelector) => boolean | T_BooleanMap = (selector?: T_UseMediaQuerySelector) => {\n        const getLastValidItem: (n:number) => boolean = (n:number) => {\n            if(typeof selector !== 'object' || !Array.isArray(selector)) return false;\n            if(selector.every(str => str === null)) return false;\n            if(n > selector.length - 1){\n                n = selector.length - 1\n            }\n            if(selector[n] === null){\n                if(n > 0){\n                    return getLastValidItem(n - 1)\n                }\n            }else{\n                return selector[n]\n            }\n        }\n        if(typeof selector === 'undefined'){\n            return matchObj\n        }\n        \n        else if(typeof selector === 'object' && Array.isArray(selector) && selector.length){\n            // console.log('args is an array:', selector)\n            let num:number = 0\n            Object.values(matchObj).map((mq:any, idx:number) => {\n                if(mq){ num = idx }\n            })\n            return getLastValidItem(num)\n        }\n        \n        else if(typeof selector === 'string'){\n            // console.log('args is a string:', selector)\n            if(selector in matchObj){\n                return matchObj[selector]\n            }else{\n                return false\n            }\n        }\n        \n        else if(typeof selector === 'number'){\n            // console.log('args is a number:', selector)\n            return Object.values(matchObj)[selector]\n        }\n        \n        else{\n            return matchObj\n        }\n    }\n    if(typeof mediaQueries === 'object' && !Array.isArray(mediaQueries)){\n        \n        useEffect(()=>{\n            if(!mediaQueries || !Object.entries(mediaQueries).length) return;\n            // console.log('useEffect | mediaQueries - object')\n            const qMap:any = {}\n            const matchMap:any = {}\n            \n            Object.entries(mediaQueries).map((tuple:any) => {\n                const list: any = window.matchMedia(tuple[1])\n                qMap[tuple[0]] = list\n                matchMap[tuple[0]] = list.matches\n            })\n            setMatchObj({...matchMap})\n            \n            // if(!Object.entries(qMap).length) return;\n            const handler: any = (e: any, item:string) => {\n                if(matchMap[item] === e.matches) return;\n                // console.log('handler:', item)\n                matchMap[item] = e.matches\n                setMatchObj({...matchMap})\n            }\n            Object.entries(qMap).forEach((tuple:any) => \n                tuple[1].addEventListener('change', (e:any) => handler(e, tuple[0]))\n            )\n            return () => { Object.entries(qMap).forEach((tuple:any) => \n                tuple[1].removeEventListener('change', (e:any) => handler(e, tuple[0]))\n            )}\n        }, [])\n        return itemAtIndex\n    }\n    else if(typeof mediaQueries === 'object' && Array.isArray(mediaQueries)){\n        \n        useEffect(()=>{\n            if(!mediaQueries || !mediaQueries.length) return;\n            // console.log('useEffect | mediaQueries - array')\n            const qMap:any = {}\n            const matchMap:any = {}\n            \n            mediaQueries.map((mqString:any, idx:number) => {\n                const list: any = window.matchMedia(mqString)\n                qMap[idx] = list\n                matchMap[idx] = list.matches\n            })\n            setMatchObj({...matchMap})\n            \n            // if(!Object.entries(qMap).length) return;\n            const handler: any = (e: any, item:string) => {\n                if(matchMap[item] === e.matches) return;\n                // console.log('handler:', item)\n                matchMap[item] = e.matches\n                // if(e.matches){}\n                setMatchObj({...matchMap})\n            }\n            Object.entries(qMap).forEach((tuple:any) => \n                tuple[1].addEventListener('change', (e:any) => handler(e, tuple[0]))\n            )\n            return () => { Object.entries(qMap).forEach((tuple:any) => \n                tuple[1].removeEventListener('change', (e:any) => handler(e, tuple[0]))\n            )}\n        }, [])\n        return itemAtIndex\n    }\n    \n    \n    else if(typeof mediaQueries === 'string'){\n        const [isMatch, setIsMatch] = useState(false)\n        const [mediaQueryList, setMediaQueryList] = useState<any>(undefined)\n        \n        useEffect(()=>{\n            const list: any = window.matchMedia(mediaQueries)\n            setMediaQueryList(list)\n            setIsMatch(list.matches)\n        }, [mediaQueries])\n        \n        useEffect(()=>{\n            const handler: any = (e: any) => setIsMatch(e.matches)\n            mediaQueryList && mediaQueryList.addEventListener('change', handler)\n            return () => mediaQueryList && mediaQueryList.removeEventListener('change', handler)\n            // log(`type of MQ list: ${typeof mediaQueryList} isArray:${Array.isArray(mediaQueryList)}`)\n        }, [mediaQueryList])\n    \n        return isMatch\n    }else{\n        return false\n    }\n}\nexport default useMediaQuery"
  },
  "useMousePosition.tsx": {
    "title": "useMousePosition",
    "description": "??",
    "doc": "",
    "content": "import {useState, useRef} from 'react'\n    \nconst useMousePosition = () => {\n    const [coords, setCoords] = useState({ x: 0, y: 0 });\n    const ref = useRef<any>(null)\n    return {\n        ...coords,\n        bind: {\n            onMouseMove: function(event: any) {\n                // const position = {\n                //     x: event.pageX,\n                //     y: event.pageY\n                //   };\n                \n                //   const offset = {\n                //     left: referenceElement.offsetLeft,\n                //     top: referenceElement.offsetTop\n                //   };\n                \n                //   let reference = referenceElement.offsetParent;\n                \n                //   while(reference){\n                //     offset.left += reference.offsetLeft;\n                //     offset.top += reference.offsetTop;\n                //     reference = reference.offsetParent;\n                //   }\n                \n                //   return { \n                //     x: position.x - offset.left,\n                //     y: position.y - offset.top,\n                //   }; \n                  \n                // const x = e.pageX - e.currentTarget.offsetLeft; \n                // const y = e.pageY - e.currentTarget.offsetTop; \n                const x = event.clientX\n                const y = event.clientY\n                setCoords({ x, y });\n            },\n        },\n    \n    };\n}\nexport default useMousePosition"
  },
  "useNotifications.tsx": {
    "title": "useNotifications",
    "description": "??",
    "doc": "",
    "content": "import {useState} from 'react'\nimport { isBrowser } from '@pratiq/utils'\nimport debug from 'debug'\nconst log = debug('@pq:useGeolocation')\nexport type I_UseNotificationOptions = {// example\n    title?: string;                     // 'Welcome!'\n    dir?: string;                       // 'rtl'\n    lang?: string;                      // 'en:US'\n    badge?: string;                     //  'path/to/image' ?\n    body?: string;                      // 'This is the notification body!'\n    tag?: string;                       // 'tag' ?\n    icon?: string;                      // 'image-url-string'\n    image?: string;                     // 'image-url-string'\n    data?: any;                         // { some: 'data' }\n    vibrate?: boolean;                  // true\n    renotify?: boolean;                 // false\n    requireInteraction?: boolean;       // true\n    actions?: I_ActionObject[];         // [ { action:'', title:'', icon:'' },  ]       \n    silent?: boolean;                   // false\n}\nexport type I_ActionObject = {\n    action: string;\n    title: string;\n    icon: string;\n}\nexport type I_UseNotificationReturn = {\n    notify: Function; \n    request: Function;\n    available: boolean; \n    permission: string;\n}\nexport type T_UseNotifications = (options?: I_UseNotificationOptions) => I_UseNotificationReturn;\nconst optionDefaults = {\n    title: 'NOTIFICATION-TITLE',\n    body: 'NOTIFICATION-BODY'\n}\nconst useNotifications: T_UseNotifications = (options: I_UseNotificationOptions = {}) => {\n    Object.assign(optionDefaults, options)\n    const empty = {\n        notify: () => {},\n        request: () => {},\n        available: false,\n        permission: 'null',\n    }\n    if(!isBrowser() || typeof Notification === 'undefined') return empty;\n    const [perm, setPerm] = useState(Notification.permission)\n    let avail = typeof window !== 'undefined' && \"Notification\" in window ? true : false\n    const requestNotifications = () => {\n        avail && Notification.requestPermission()\n                .then(permission => {\n                    setPerm(permission)\n                })\n    }\n    const sendNotification = (_options: I_UseNotificationOptions = {}) => {\n        let tempOpt = Object.assign({...options}, _options)\n        if (perm === 'granted' && avail) {\n            //@ts-ignore\n            new Notification(tempOpt.title, tempOpt);\n        } \n        else if(perm !== 'denied' && avail){\n            Notification.requestPermission()\n                .then(permission => {\n                    setPerm(permission)\n                    sendNotification()\n                })\n        }\n        else {\n            return;\n        }\n    };\n    return {\n        notify: sendNotification, \n        request: requestNotifications, \n        available: avail, \n        permission: perm\n    }\n};\nexport default useNotifications"
  },
  "usePerformance.tsx": {
    "title": "usePerformance",
    "description": "??",
    "doc": "",
    "content": "import {useState, useRef, useMemo, useEffect, useCallback} from 'react'\nexport interface I_PerfData {\n    timeStamp: number;\n    delta: number;\n}\nexport interface I_PerfConfig {\n    roll?: number;\n    capacity?: number;\n    float?: boolean;\n    floatLength?: number;\n}\nconst usePerformance = (config: I_PerfConfig) => {\n    const [trigger, setTrigger] = useState<any>(false)\n    const [internalTrigger, setInternalTrigger] = useState(false)\n    const totalTicks = useRef(0)\n    const data = useRef<any>([])\n    const last = useRef(0)\n    const average = useRef(0)\n    const rollingAverage = useRef(0)\n    const totalTime = useRef(0)\n    const rollingTotalTime = useRef(0)\n    const min = useRef(0)\n    const max = useRef(0)\n    const ticksPerSecond = useRef(0)\n    const tNow = useRef(0)\n    const tpsTimeoutRef = useRef<any>(0)\n    const initRef = useRef<any>(false)\n    const shouldTickRef = useRef<any>(false)\n    let delta = useRef(0)\n    const settings = useMemo(() => ({\n        roll: config?.roll                  ?? 100,\n        capacity: config?.capacity          ?? 10000,\n        float: config?.float                ?? true,\n        floatLength: config?.floatLength    ?? 4,\n    }), [config])\n    const getNow = (() => {\n        var performance:any = window.performance || {};\n          \n        performance.now = (() => {\n          return performance.now    ||\n          performance.webkitNow     ||\n          performance.msNow         ||\n          performance.oNow          ||\n          performance.mozNow        ||\n          (() => new Date().getTime())\n        })();\n                \n        return performance.now();         \n    });\n      \n    const toFixedNumber = (num: number, digits: number, base: number = 10) => {\n        var pow = Math.pow(base, digits);\n        return Math.round(num*pow) / pow;\n    }\n    const findTicksPerSecond = useCallback(() => {\n        let tps = data.current.filter((p: any) => p.timeStamp >= tNow.current - 1000).map((p:any) => p.timeStamp).length\n        ticksPerSecond.current = tps\n        clearTimeout(tpsTimeoutRef.current)\n        if(tps !== 0){\n            tpsTimeoutRef.current = setTimeout(() => {\n                tNow.current = getNow()\n                findTicksPerSecond()\n            }, 1000);\n        }\n    }, [data])\n    const tick = useCallback(() => {\n        console.log('tick >>>')\n        tNow.current = getNow()\n        // console.log('tNow:', tNow.current)\n        if(!data.current.length){\n            // console.log('>> empty data array, pushing( time: now , delta: 0)')\n            data.current = [{\n                timeStamp: tNow.current,\n                delta: 0,\n            }]\n            console.log('first data:', data.current)\n            // setInternalTrigger(b=>!b)\n        }\n        else{\n            // console.log('>> one data entry, pushing( time: now , delta: realDelta)')\n            delta.current = tNow.current - data.current[data.current.length - 1].timeStamp\n            data.current = [...data.current, {\n                timeStamp: tNow.current,\n                delta: delta.current\n            }]\n            console.log('new data:', data.current)\n            if(data.current.length > settings.capacity){\n                data.current = [...data.current.shift()]\n            }\n            // console.log('delta:', delta.current)\n            last.current = settings.float \n                ? toFixedNumber(delta.current, settings.floatLength)\n                : toFixedNumber(delta.current, 0)\n        }\n        if(data && data.current.length && data.current.length > 1){\n            // console.log('>> more than one data entry, pushing( time: now , delta: realDelta)')\n            let tot = data.current[data.current.length - 1].timeStamp - data.current[0].timeStamp\n            totalTime.current = settings.float \n                ? toFixedNumber(tot, settings.floatLength)\n                : toFixedNumber(tot, 0)\n            /// total average of all ticks\n            average.current = settings.float ? toFixedNumber((tot / data.current.length), settings.floatLength) : toFixedNumber((tot / data.current.length), 0)\n            \n            /// rolling total using number of ticks (10 by default)    \n            if(settings.roll > 0){\n                let rollTot = data.current[data.current.length - 1].timeStamp - data.current[data.current.length > settings.roll ? data.current.length - settings.roll : 0].timeStamp  \n                rollingTotalTime.current = settings.float \n                    ? toFixedNumber(rollTot, settings.floatLength)\n                    : toFixedNumber(rollTot, 0)\n                rollingAverage.current = settings.float \n                ? toFixedNumber(rollTot / (data.current.length > settings.roll ? settings.roll : data.current.length), settings.floatLength)\n                : toFixedNumber(rollTot / (data.current.length > settings.roll ? settings.roll : data.current.length), 0)\n            }      \n            /// min/max of all ticks (if delta is not 0)\n            let deltaArray = data.current.filter((p: any) => p.delta !== 0).map((p:any) => p.delta)\n            min.current = settings.float \n                ? toFixedNumber(Math.min(...deltaArray), settings.floatLength)\n                : toFixedNumber(Math.min(...deltaArray), 0)\n            max.current = settings.float \n                ? toFixedNumber(Math.max(...deltaArray), settings.floatLength)\n                : toFixedNumber(Math.max(...deltaArray), 0)\n            /// ticks per second - filter for deltas that are within last second of timestamps?\n            findTicksPerSecond()\n            \n        }\n        \n        setInternalTrigger(b=>!b)\n    }, [settings.roll, settings.float, findTicksPerSecond, settings.capacity, settings.floatLength])\n    const reset = () => {\n        totalTicks.current = 0\n        data.current = []\n        last.current = 0\n        average.current = 0\n        rollingAverage.current = 0\n        totalTime.current = 0\n        rollingTotalTime.current = 0\n        min.current = 0\n        max.current = 0\n        ticksPerSecond.current = 0\n        setInternalTrigger((b:boolean) => !b)\n    }\n    const lastTriggerRef = useRef(false)\n    useEffect(()=>{\n        if(!initRef.current){\n            initRef.current = true\n            return\n        }\n        totalTicks.current ++\n        console.log('was triggered?')\n        tick()\n      \n            \n    }, [trigger, tick])\n    return {\n        reset,\n        tick: () => setTrigger((t:boolean) => !t),\n        totalTicks: totalTicks.current,\n        data: data.current,\n        tps: ticksPerSecond.current,\n        average: average.current,\n        rollingAverage: rollingAverage.current,\n        totalTime: totalTime.current,\n        rollingTotalTime: rollingTotalTime.current,\n        min: min.current,\n        max: max.current,\n        last: last.current,\n        trigger\n    }\n}\nexport default usePerformance"
  },
  "useStateArray.tsx": {
    "title": "useStateArray",
    "description": "??",
    "doc": "",
    "content": "import { useState } from 'react'\n    \ntype T_useStateArrayReturn = {\n    array: any[];\n    set: (v:any[] | Function) => void;\n    clear: () => void;\n    reset: () => void\n    filter: (cb: (value: any, index: number, array: any[]) => typeof value ) => void;\n    push: (...values:any) => void;\n    pop: () => any;\n    copyWithin: (target:number, start?:number, end?:number) => void;\n    fill: (element:any, start?:number, end?:number, length?: number) => void \n    reduce: (cb: any, initialValue?:any) => void;\n    reduceRight: (cb: any, initialValue?:any) => void;\n    reverse: () => void;\n    sort: (cb: (a: any, b: any) => number) => void;\n    shift: () => void;\n    unshift: (...values:any) => void;\n    splice: (start: number, deleteCount?: number, items?:any) => void;\n    flat: (depth?: number) => void;\n    insert: (index: number, element: any) => void;\n    remove: (index: number) => void;\n}\ntype T_useStateArray = (initialState: any[]) => T_useStateArrayReturn\nconst useStateArray: T_useStateArray = (initialState: any[] = []) => {\n    const [array, setArray] = useState<any[]>(initialState)\n    \n    const set = (v:any[] | Function) => {\n        if(Array.isArray(v)){\n            setArray(v)\n        }\n        if(typeof v === 'function'){\n            setArray(v(array))\n        }\n    }\n    \n    \n    const clear:        () => void           =  () => setArray([])\n    \n    const reset:        () => void           =  () => setArray(initialState)\n    \n    \n    const filter: (cb:Function) => void\n        = (cb: any) => typeof cb === 'function' && setArray((a: any[]) => a.filter(cb))\n    \n    const push: (...values: any) => void\n        = (...values: any) => {\n            setArray(a => [...a, ...values]);\n            return array.length + values.length\n        }\n    \n    \n    const pop: () => any\n        = () => {\n            setArray(a => a.slice(0, a.length - 1))\n            return array[array.length - 1]\n        }\n    \n    \n    const copyWithin: (target:number, start?:number, end?:number) => void \n        = (target:number, start:number = 0, end?:number) => {\n            setArray((a:any[]) => a.copyWithin(target, start, end))\n        }\n    \n    const fill: (element:any, start?:number, end?:number, length?: number) => void \n        = (element:any, start:number = 0, end:number = array.length, length?: number) => {\n            if(length && length > array.length){\n                let emptyArray:any = []\n                while(emptyArray.length < length - array.length){\n                    emptyArray.push(0)\n                }\n                let newArray = [...array, ...emptyArray]\n                console.log('Filling array with length')\n                setArray(newArray.fill(element, start, end))\n            }else{\n                console.log('Filling array from start-end')\n                let newArr = array.fill(element, start, end)\n                console.log('newArr:', newArr)\n                setArray([...newArr])\n            }\n        }\n    \n    const reduce: (cb: any, initialValue?:any) => void \n        = (cb: any, initialValue:any = 0) => setArray([array.reduce(cb, initialValue)])\n    \n    const reduceRight: (cb: any, initialValue?:any) => void \n        = (cb: any, initialValue:any = 0) => setArray([array.reduceRight(cb, initialValue)])\n    \n    const reverse: () => void \n        = () => {\n            let newArray = [...array]\n            newArray.reverse()\n            setArray(newArray)\n        }\n    \n    const sort: (cb?:any) => void \n        = (cb?:any) => {\n            let newArr = [...array.sort(cb)]\n            setArray(newArr)\n        }\n    \n    const shift: () => void \n        = () => {\n            let shifted = array.shift()\n            setArray(array)\n            return shifted\n        }\n    \n    \n    const unshift: (...values:any) => void \n        = (...values:any) => {\n            let length = array.length + values.length\n            setArray(a => [...values, ...a])\n            return length\n        }\n    \n    const splice: (start: number, deleteCount?: number, items?:any) => void \n        = (start: number, deleteCount: number = 0, items?:any) => {\n            array.splice(start, deleteCount, items)\n            setArray(array)\n        }\n    \n    const flat: (i?: number) => void\n        = (i?: number) => setArray(a => a.flat(i ?? 10000))\n    \n    const insert: (i: number, e: any) => void \n        = (i: number, e: any) => {\n            if(i > array.length || i < 0){ return }\n            setArray(a => [...a.slice(0, i), e, ...a.slice(i + 1, a.length) ])\n        }\n    \n    const remove: (i: number) => void \n        = (i: number) => {\n            i && setArray(a => [\n                ...a.slice(0, i),\n                ...a.slice(i + 1, a.length)\n            ])\n        }\n    \n    return {\n        \n        array,\n        set,\n        clear,\n        reset,\n        filter,\n        push,\n        pop,\n        copyWithin,\n        fill,\n        reduce,\n        reduceRight,\n        reverse,\n        sort,\n        shift,\n        unshift,\n        splice,\n        flat,\n        insert,\n        remove\n    }\n}\nexport default useStateArray"
  },
  "useStateMap.tsx": {
    "title": "useStateMap",
    "description": "??",
    "doc": "",
    "content": "import { useState, useEffect } from 'react'\nimport debug from 'debug'\nconst log = debug('useStateMap')\ndebug.enable('useStateMap')\ntype T_useStateMapReturn = {\n    value: Map<any, any>;\n}\ntype T_useStateMap = <K, V>(initialState?: Iterable<readonly [K, V]>) => T_useStateMapReturn\nconst useStateMap: T_useStateMap = <K, V>(initialState?: Iterable<readonly [K, V]>) => {\n    const [mapState, setMapState] = useState<Map<K, V>>(new Map(initialState))\n    const set = (key: K, value: V) => {\n        log(`Setting \"${key}\" => \"${value}\"`)\n        let newMap = new Map(mapState)\n        newMap.set(key, value)\n        setMapState(newMap)\n        return newMap.get(key) === value\n    }\n    \n    const get = (key: K) => {\n        log(`Getting key from Map:`, key)\n        return mapState.get(key)\n    }\n    \n    const remove = (key: K) => {\n        log(`Removing item from Map:`, key)\n        let newMap = new Map(mapState)\n        newMap.delete(key)\n        setMapState(newMap)\n    }\n    const clear = () => {\n        setMapState(new Map())\n    }\n    const reset = () => {\n        setMapState(new Map(initialState))\n    }\n    useEffect(()=>{\n        log('Map:', mapState)\n    }, [mapState])\n    return {\n        value: mapState,\n        set,\n        get,\n        remove,\n        clear,\n        reset\n    }\n}\nexport default useStateMap"
  },
  "useStateSet.tsx": {
    "title": "useStateSet",
    "description": "??",
    "doc": "",
    "content": "import debug from 'debug'\nconst log = debug('useStateSet')\ndebug.enable('useStateSet')\nimport { useState, useEffect } from 'react'\nexport type T_UseStateSetReturn<T> = {\n    value: Set<T>,\n    add: (item: T) => boolean,\n    remove: (item: T) => boolean,\n    clear: () => void,\n    reset: () => void,\n}\nconst useStateSet = <T extends any>(initialState?: Iterable<T>): T_UseStateSetReturn<T> => {\n    const [value, setValue] = useState<Set<T>>(new Set(initialState))\n    const add = (item: T) => {\n        log(`Adding item to set:`, item)\n        let newSet = new Set(value)\n        let ret = !newSet.has(item)\n        newSet.add(item)\n        setValue(newSet)\n        return ret\n    }\n    \n    const remove = (item:T) => {\n        log(`Removing item from set:`, item)\n        let newSet = new Set(value)\n        let ret = newSet.delete(item)\n        setValue(newSet)\n        return ret\n    }\n    const clear = () => {\n        setValue(new Set())\n    }\n    const reset = () => {\n        setValue(new Set(initialState))\n    }\n    useEffect(()=>{\n        log('value:', value)\n    }, [value])\n    return {\n        value,\n        add,\n        remove,\n        clear,\n        reset\n    }\n}\nexport default useStateSet\n// const comp = () => {\n//     const { value } = useStateSet([true, 123, 'hello'])\n// }"
  },
  "useStateWithHistory.tsx": {
    "title": "useStateWithHistory",
    "description": "??",
    "doc": "",
    "content": "import {useState, useRef, useCallback} from 'react'\n    \ntype T_UseStateWithHistory = <T>(initialValue:any, maxHistory: number) => {\n    value:T;\n    history: T[],\n    pointer: number,\n    setValue: (value:any) => void;\n    forward: (amount?:number) => void;\n    back: (amount?:number) => void;\n    goto: (index:number) => void;\n}\nconst useStateWithHistory: T_UseStateWithHistory = (initialValue: any, maxHistory: number) => {\n    let capacity = maxHistory ?? 10\n    const [value, setValue] = useState<any>(initialValue)\n    const historyRef = useRef<any[]>([value])\n    const pointerRef = useRef<number>(0)\n    const set = useCallback((v: any) => {\n        const resolvedValue = typeof v === 'function' ? v(value) : v\n        if(historyRef.current[pointerRef.current] !== resolvedValue){\n            if(pointerRef.current < historyRef.current.length){\n                historyRef.current.splice(pointerRef.current + 1)\n            }\n            historyRef.current.push(resolvedValue)\n            if(historyRef.current.length > capacity){\n                historyRef.current.shift()\n            }\n            pointerRef.current = historyRef.current.length - 1\n        }\n        setValue(resolvedValue)\n    }, [capacity, value])\n    const back = useCallback((i?: number)=>{\n        if(typeof i === 'number'){\n            console.log(`go back custom amount ${i}`)\n            if(pointerRef.current >= i){\n                pointerRef.current = pointerRef.current - i\n                setValue(historyRef.current[pointerRef.current])\n            }else{\n                pointerRef.current = 0\n                setValue(historyRef.current[0])\n            }\n        }else{\n            if(pointerRef.current > 0){\n                pointerRef.current--\n                setValue(historyRef.current[pointerRef.current])\n            }\n        }\n    }, [])\n    const forward = useCallback((i?: number)=>{\n        if(typeof i === 'number'){\n            if(pointerRef.current + i < historyRef.current.length - 1){\n                console.log(`FORWARD | go forward ${i} - from ${pointerRef.current} to ${pointerRef.current + i}`)\n                pointerRef.current = pointerRef.current + i\n                setValue(historyRef.current[pointerRef.current])\n            }else{\n                pointerRef.current = historyRef.current.length - 1\n                setValue(historyRef.current[pointerRef.current])\n            }\n        }else{\n            if(pointerRef.current < historyRef.current.length - 1){\n                pointerRef.current++\n                setValue(historyRef.current[pointerRef.current])\n            }\n        }\n        \n    }, [])\n    \n    const goto = useCallback(index => {\n        if(index > 0 || index < historyRef.current.length){\n            pointerRef.current = index\n            setValue(historyRef.current[pointerRef.current])\n        }\n    }, [])\n    return {\n        value,\n        history: historyRef.current,\n        pointer: pointerRef.current,\n        setValue: set,\n        forward,\n        back,\n        goto,\n    }\n}\nexport default useStateWithHistory"
  },
  "useStateWithValidation.tsx": {
    "title": "useStateWithValidation",
    "description": "??",
    "doc": "",
    "content": "import {useState, useCallback, useEffect, useMemo} from 'react'\n    \nexport type T_UseStateWithValidationConfig = {\n    validator?: RegExp | string | ((value:any) => boolean);\n    value?: any;\n}\nexport type T_UseStateWithValidation = <T>(config?: T_UseStateWithValidationConfig) => {\n    value: T;\n    setValue: (v:any) => void;\n    isValid: boolean;\n    lastValidValue: any;\n}\nconst useStateWithValidation = <T,>(config: T_UseStateWithValidationConfig = {}) => {\n    \n    type T_UseStateWithValidationReturn = {\n        value: T;\n        setValue: (v:any) => void;\n        isValid: boolean;\n        lastValidValue: any;\n    }\n    const settings = useMemo(() => ({\n        validator:  config.validator    ?? function(){},\n        value:      config.value        ?? null\n    }), [config])\n    const handleValidate = (v: any) => {\n        return typeof settings.validator === 'function' \n                ? settings.validator(v) \n                : settings.validator instanceof RegExp\n                    ? v.test(settings.validator)\n                    : v === settings.validator\n    }\n    const [value, setValue] = useState<T>(settings.value)\n    const [lastValidValue, setLastValidValue] = useState<null | T>(null)\n    const [isValid, setIsValid] = useState<boolean>(() => handleValidate(settings.value))\n    const handleChange = useCallback(newValue => {\n        const v = typeof newValue === 'function' ? newValue(value) : newValue\n        setValue(v)\n        let isV = handleValidate(v)\n        setIsValid(isV)\n        isV && setLastValidValue(v)\n    }, [settings.validator, value])\n    useEffect(()=>{\n        let isV = handleValidate(value)\n        setIsValid(isV)\n        isV && setLastValidValue(value)\n    },[])\n    // return [value, handleChange, isValid, lastValidValue]\n    return {\n        value,\n        setValue: handleChange,\n        isValid,\n        lastValidValue\n    }\n}\nexport default useStateWithValidation"
  },
  "useStorage.tsx": {
    "title": "useStorage",
    "description": "??",
    "doc": "",
    "content": "import {useState, useEffect, useRef} from 'react'\n    \nconst useStorage = (key: string, initialValue: any, storageObject: any) => {\n    const [value, setValue] = useState(()=>{\n        const jsonValue = storageObject.getItem(key)\n        if (jsonValue != null) return JSON.parse(jsonValue)\n        if (typeof initialValue === 'function'){\n            return initialValue()\n        }else{\n            return initialValue\n        }\n    })\n    const remove = () => { \n        storageObject.removeItem(key);\n    }\n    useEffect(()=>{\n        storageObject.setItem(key, JSON.stringify(value))\n    }, [key, value, storageObject])\n    return [value, setValue, remove]\n}\nexport const useLocalStorage = (key: string, initialValue: any) => {\n    return useStorage(key, initialValue, window.localStorage)\n}\nexport const useSessionStorage = (key: string, initialValue: any) => {\n    return useStorage(key, initialValue, window.sessionStorage)\n}\nexport default useStorage"
  },
  "useTemperature.tsx": {
    "title": "useTemperature",
    "description": "??",
    "doc": "",
    "content": "import {useState, useEffect, useCallback, useMemo} from 'react'\nimport { isBrowser } from '@pratiq/utils'\nimport debug from 'debug'\nconst log = debug('@pq:useTemperature')\nexport interface I_UseTemperatureConfig { \n    scale?: string;\n    value?: number;\n    decimals?: number;\n}\ntype T_UseTemperature = (config?: I_UseTemperatureConfig) => {\n    value: number; \n    setValue: (value:number) => void;\n    scale: string;\n    setScale: (scale:string) => void;\n    celsius: number;\n    fahrenheit: number;\n    kelvin: number;\n    rankine: number;\n    relative: string;\n    increment: () => void;\n    decrement: () => void;\n    c_to_f: (value:number) => number;\n    c_to_k: (value:number) => number;\n    c_to_r: (value:number) => number;\n    \n    f_to_c: (value:number) => number;\n    f_to_k: (value:number) => number;\n    f_to_r: (value:number) => number;\n    \n    k_to_c: (value:number) => number;\n    k_to_f: (value:number) => number;\n    k_to_r: (value:number) => number;\n    \n    r_to_c: (value:number) => number;\n    r_to_k: (value:number) => number;\n    r_to_f: (value:number) => number;\n}\nconst useTemperature: T_UseTemperature = (config: I_UseTemperatureConfig = {}) => {\n    const settings = useMemo(()=>({\n        value: config.value         ?? 0,\n        scale: config.scale         ?? 'c',\n        decimals: config.decimals   ?? 2\n    }),[\n        config.value,\n        config.scale,\n        config.decimals\n    ])\n    const [_value, set_value] = useState(settings.value)\n    const [_defaultScale, set_defaultScale] = useState(settings.scale)\n    const [_c, set_c] = useState(0)\n    const [_f, set_f] = useState(0)\n    const [_k, set_k] = useState(0)\n    const [_r, set_r] = useState(0)\n    const [_relativeTemperature, set_relativeTemperature] = useState('')\n    // const [_argumentScale, set_argumentScale] = useState(_defaultScale)\n    //- DETERMINE SCALES --------------------------------------------------------------------------\n    const _determineScaleOfArgument = (s: string) =>{\n        switch(s.toLowerCase()){\n            case 'f':\n            case 'fahrenheit': return 'f';\n            case 'k':\n            case 'kelvin': return 'k';\n            case 'r':\n            case 'rankine': return 'r';\n            default: return 'c'\n        }\n    }\n    const _determineDefaultScale = (s: string) =>{\n        log(`findBaseScale ${s}`)\n        set_defaultScale(_determineScaleOfArgument(s))\n    }\n    const _handleScaleChange = (s: string) => {\n        switch(s){\n            case 'f':\n            case 'fahrenheit': set_value(_f); break;\n            \n            case 'k':\n            case 'kelvin': set_value(_k); break;\n            case 'r':\n            case 'rankine': set_value(_r); break;\n            \n            default: set_value(_c);\n        }\n    }\n    // - DECIMALS -------------------------------------------------------------------------\n    const handle_f = (t: number) => set_f(parseFloat(t.toFixed(settings.decimals)))\n    const handle_c = (t: number) => set_c(parseFloat(t.toFixed(settings.decimals)))\n    const handle_k = (t: number) => set_k(parseFloat(t.toFixed(settings.decimals)))\n    const handle_r = (t: number) => set_r(parseFloat(t.toFixed(settings.decimals)))\n    const handle_v = (t: number) => set_value(parseFloat(t.toFixed(settings.decimals)))\n    //- CONVERSIONS -------------------------------------------------------------------------------\n    const _convert = {\n        \n        c_f: (c: number) => c * 1.8 + 32,\n        \n        c_k: (c: number) => c + 273.15,\n        \n        c_r: (c: number) => (c + 273.15) * 1.8,\n        \n        k_f: (k: number) =>  k * 1.8 - 459.67,\n        \n        k_c: (k: number) => k - 273.15,\n        \n        k_r: (k: number) => k * 1.8,\n        \n        f_c: (f: number) => (f - 32) / 1.8,\n        \n        f_k: (f: number) => (f + 459.67) * (5/9),\n        \n        f_r: (f: number) => f + 459.67,\n        \n        r_f: (r: number) => r - 459.67,\n        \n        r_k: (r: number) => r * (5/9),\n        \n        r_c: (r: number) => (r - 491.67) * (5/9)\n    }\n    //- EXPORTED HANDLER ---------------------------------------------------------------------------\n    const _handleValue = (value: number | Function, s?: string) => {\n        let t: number; // typecast to number (inputs use strings)\n        if(typeof value === 'function'){\n            t = value(_value)\n        }else{\n            t = value - 0\n        }\n        \n        let _scaleOfArgument = s ? _determineScaleOfArgument(s) : _defaultScale\n        if(_scaleOfArgument === 'c'){\n            handle_f(_convert.c_f(t))\n            handle_k(_convert.c_k(t))\n            handle_r(_convert.c_r(t))\n            handle_c(t)\n            switch(_defaultScale){\n                case 'f': handle_v(_convert.c_f(t)); break;\n                case 'k': handle_v(_convert.c_k(t)); break;\n                case 'r': handle_v(_convert.c_r(t)); break;\n                case 'c': handle_v(t); break;\n            }\n        }\n        if(_scaleOfArgument === 'k'){\n            handle_f(_convert.k_f(t))\n            handle_c(_convert.k_c(t))\n            handle_r(_convert.k_r(t))\n            handle_k(t)\n            switch(_defaultScale){\n                case 'f': handle_v(_convert.k_f(t) ); break;\n                case 'c': handle_v(_convert.k_c(t) ); break;\n                case 'r': handle_v(_convert.k_r(t) ); break;\n                case 'k': handle_v(t); break;\n            }\n        }\n        if(_scaleOfArgument === 'f'){\n            handle_c(_convert.f_c(t))\n            handle_k(_convert.f_k(t))\n            handle_k(_convert.f_r(t))\n            handle_f(t)\n            switch(_defaultScale){\n                case 'c': handle_v(_convert.f_c(t) ); break;\n                case 'k': handle_v(_convert.f_k(t) ); break;\n                case 'r': handle_v(_convert.f_r(t) ); break;\n                case 'f': handle_v(t); break;\n            }\n        }\n        if(_scaleOfArgument === 'r'){\n            handle_c(_convert.r_c(t))\n            handle_k(_convert.r_k(t))\n            handle_f(_convert.r_f(t))\n            handle_r(t)\n            switch(_defaultScale){\n                case 'f': handle_v( _convert.r_f(t) ); break;\n                case 'c': handle_v( _convert.r_c(t) ); break;\n                case 'k': handle_v( _convert.r_k(t) ); break;\n                case 'r': handle_v(t); break;\n            }\n        }\n        \n        \n    }\n    const _determineRelativeTemperature = useCallback(() => {\n        if (_f <= 32)                   set_relativeTemperature('freezing')\n        else if (_f > 32 && _f <= 50)   set_relativeTemperature('cold')\n        else if (_f > 50 && _f <= 60)   set_relativeTemperature('cool')\n        else if (_f > 60 && _f <= 70)   set_relativeTemperature('moderate')\n        else if (_f > 70 && _f <= 80)   set_relativeTemperature('warm')\n        else                            set_relativeTemperature('hot')\n    }, [_f])\n    const increment = () => { _handleValue(parseInt(_value.toString()) + 1) }\n    const decrement = () => { _handleValue(parseInt(_value.toString()) - 1) }\n    \n    useEffect(()=>{\n        _determineRelativeTemperature() \n    }, [_f, _determineRelativeTemperature, _value])\n    // useEffect(()=>{\n    //     _determineDefaultScale(settings.scale) \n    // }, [settings.scale])\n    useEffect(()=>{\n        _handleScaleChange(_defaultScale)\n    },[_defaultScale])\n    useEffect(()=>{\n        _handleValue(settings.value, settings.scale)\n    }, [settings.value])\n    // useEffect(()=>{\n        // _determineDefaultScale(_defaultScale)\n    // },[settings.scale, _defaultScale])\n    return {\n        value: _value, \n        setValue: _handleValue,\n        scale: _defaultScale,\n        setScale: (v:string) => set_defaultScale(_determineScaleOfArgument(v)),\n        celsius: _c,\n        fahrenheit: _f,\n        kelvin: _k,\n        rankine: _r,\n        relative: _relativeTemperature,\n        increment,\n        decrement,\n        c_to_f: _convert.c_f,\n        c_to_k: _convert.c_k,\n        c_to_r: _convert.c_r,\n        \n        f_to_c: _convert.f_c,\n        f_to_k: _convert.f_k,\n        f_to_r: _convert.f_r,\n        \n        k_to_c: _convert.k_c,\n        k_to_f: _convert.k_f,\n        k_to_r: _convert.k_r,\n        \n        r_to_c: _convert.r_c,\n        r_to_k: _convert.r_k,\n        r_to_f: _convert.r_f,\n    }\n}\nexport default useTemperature"
  },
  "useTime.tsx": {
    "title": "useTime",
    "description": "??",
    "doc": "",
    "content": "import { useState, useEffect } from 'react';\nimport useInterval from './useInterval.js';\n \n// const timezoneLabels: Record<string, string> = {\n//     'UTC': '+00:00',\n//     'GMT': '+00:00',\n//     'EST': '-05:00', // Eastern Standard Time (North America)\n//     'EDT': '-04:00', // Eastern Daylight Time (North America)\n//     'CST': '-06:00', // Central Standard Time (North America)\n//     'CDT': '-05:00', // Central Daylight Time (North America)\n//     'MST': '-07:00', // Mountain Standard Time (North America)\n//     'MDT': '-06:00', // Mountain Daylight Time (North America)\n//     'PST': '-08:00', // Pacific Standard Time (North America)\n//     'PDT': '-07:00', // Pacific Daylight Time (North America)\n//     'WET': '+00:00', // Western European Time\n//     'CET': '+01:00', // Central European Time\n//     'CEST': '+02:00', // Central European Summer Time\n//     'EET': '+02:00', // Eastern European Time\n//     'EEST': '+03:00', // Eastern European Summer Time\n//     'IST': '+05:30', // Indian Standard Time\n//     'CST_CN': '+08:00', // China Standard Time\n//     'JST': '+09:00', // Japan Standard Time\n//     'AEST': '+10:00', // Australian Eastern Standard Time\n//     'AEDT': '+11:00', // Australian Eastern Daylight Time\n//     // ... add more as needed ...\n// };\n// const getTimezoneOffset = (timezone:string):number => {\n//   if (!timezone) return 0;\n//   if (timezoneLabels[timezone]) {\n//     timezone = timezoneLabels[timezone];\n//   }\n//   const match = timezone.match(/^([+\\-]?)(\\d{2}):(\\d{2})$/);\n//   if (match) {\n//     const sign = match[1] === '-' ? -1 : 1;\n//     const hours = parseInt(match[2]);\n//     const minutes = parseInt(match[3]);\n//     return sign * ((hours * 60 + minutes) * 60 * 1000);\n//   }\n//   console.warn('Invalid timezone provided:', timezone);\n//   return 0;\n// };\nconst formatTime = (date:Date, formatString:string):string => {\n    const hour12 = date.getHours() % 12 || 12;\n    const amPm = date.getHours() < 12 ? 'AM' : 'PM';\n    const replacements: Record<string, string> = {\n        '%Y': String(date.getFullYear()),\n        '%M': String(date.getMonth() + 1).padStart(2, '0'),\n        '%D': String(date.getDate()).padStart(2, '0'),\n        '%H': String(date.getHours()).padStart(2, '0'),\n        '%h': String(hour12).padStart(2, '0'),\n        '%m': String(date.getMinutes()).padStart(2, '0'),\n        '%s': String(date.getSeconds()).padStart(2, '0'),\n        '%S': String(date.getMilliseconds()).padStart(2, '0'),\n        '%t': String(date.getTime()).padStart(2, '0'),\n        '%p': amPm\n    };\n    return formatString.replace(/%Y|%M|%D|%H|%h|%m|%s|%S|%t|%p/g, (match) => replacements[match]);\n};\nexport type UseTimeConfig = {\n    // timezone: keyof typeof timezoneLabels;\n    format: string;\n    interval: number;\n}\nexport type UseTimeReturn = {\n    rawTime: number;\n    time: string;\n}\n/*\n{\n    timezone = 'GMT',\n    format = '%Y-%M-%D %h:%m:%s',\n    interval = 1000\n}\n*/\nconst useTime = (config: UseTimeConfig):UseTimeReturn => {\n    const settings = {\n        // offset: getTimezoneOffset(config?.timezone ?? 'UTC'),\n        interval: config?.interval ?? 1000,\n        format: config?.format ?? '%Y-%M-%D %h:%m:%s'\n    }\n    \n    const [rawTime, setRawTime] = useState(Date.now());\n    const [time, setTime] = useState('NO TIME SET YET');\n    useInterval(() => {\n        // Adding the offset and setting the raw time\n        setRawTime(Date.now());\n    }, settings.interval, {\n        autoStart: true\n    });\n    useEffect(() => {\n        // Parsing the raw time according to the provided format\n        const date = new Date(rawTime);\n        const parsedTime = formatTime(date, settings.format);\n        setTime(parsedTime);\n    }, [rawTime, settings.format]);\n    return { rawTime, time };\n};\nexport default useTime"
  },
  "useUpdateEffect.tsx": {
    "title": "useUpdateEffect",
    "description": "??",
    "doc": "",
    "content": "import { EffectCallback, useEffect, useRef } from 'react';\nconst useUpdateEffect = (effect: EffectCallback | (() => void), deps: any[] = []) => {\n  const isMounted = useRef(false);\n  useEffect(() => {\n    if (!isMounted.current) {\n      // Skip the effect on mount\n      isMounted.current = true;\n      return;\n    }\n    console.log('Running update effect...')\n    effect();\n  }, deps);\n}\nexport default useUpdateEffect"
  },
  "useWindow.tsx": {
    "title": "useWindow",
    "description": "??",
    "doc": "",
    "content": "import {useState, useEffect} from 'react'\nimport { isBrowser } from '@pratiq/utils'\nimport debug from 'debug'\nconst log = debug('@pq:useGeolocation')\nconst useWindow = () => {\n    if (!isBrowser()) return {};\n    let _body = document.body,\n        _html = document.documentElement;\n    function toFixedNumber(num: number, digits: number = 0, base: number = 10){\n        var pow = Math.pow(base, digits);\n        return Math.round(num*pow) / pow;\n    }\n    const [coords, setCoords] = useState({x:0, y:0})\n    const [windowSize, setWindowSize] = useState<any>({\n        width: window.innerWidth,\n        height: window.innerHeight,\n        ratio: toFixedNumber(window.innerWidth / window.innerHeight, 2),\n        maxHeight: Math.max( _body.scrollHeight, _body.offsetHeight, _html.clientHeight, _html.scrollHeight, _html.offsetHeight ),\n        scrollY: toFixedNumber(window.scrollY),\n        scrollX: toFixedNumber(window.scrollX),\n        angle: 0,\n        type: 'landscape-primary',\n        orientation: '...'\n    })\n    const handler = () => {\n        const screen = window?.screen as any\n        var so = screen?.orientation || screen?.mozOrientation || screen?.msOrientation;\n        const angle = so.angle || 0\n        const type = so.type || 'landscape-primm'\n        setWindowSize({\n            width: window.innerWidth,\n            height: window.innerHeight,\n            // ratio: window.innerWidth > window.innerHeight ? (window.innerWidth / window.innerHeight).toFixed(2) : window.innerHeight / window.innerWidth,\n            ratio: toFixedNumber(window.innerWidth / window.innerHeight, 2),\n            maxHeight: Math.max( _body.scrollHeight, _body.offsetHeight, _html.clientHeight, _html.scrollHeight, _html.offsetHeight ),\n            scrollY: toFixedNumber(window.scrollY),\n            scrollX: toFixedNumber(window.scrollX),\n            angle,\n            type,\n            orientation: window.innerWidth > window.innerHeight ? 'landscape' : 'portrait'\n        })\n    }\n    const mouseHandler = (e: MouseEvent) => {\n        setCoords({x:e.clientX, y: e.clientY})\n    }\n    useEffect(() => {\n        handler()\n        window.addEventListener('resize', handler)\n        window.addEventListener('scroll', handler)\n        window.addEventListener('mousemove', mouseHandler)\n        window.screen.orientation.addEventListener('change', handler, true);\n        \n        return () => {\n            window.removeEventListener('resize', handler)\n            window.removeEventListener('scroll', handler)\n            window.removeEventListener('mousemove', mouseHandler)\n            window.screen.orientation.removeEventListener('change', handler, true);\n        }\n    }, [])\n    return {...windowSize, ...coords}\n}\nexport default useWindow"
  }
}